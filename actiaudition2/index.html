<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>AcTi Live Audition</title>
    <!-- 홈 화면 아이콘 추가 -->
    <link rel="apple-touch-icon" href="audition2.png">
    <script src="https://cdn.tailwindcss.com"></script>
    <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/pdf.js/2.11.338/pdf.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/html2canvas/1.4.1/html2canvas.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/jspdf/2.5.1/jspdf.umd.min.js"></script>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&family=Noto+Sans+KR:wght@400;500;700&display=swap" rel="stylesheet">
    <style>
        :root {
            --bg-primary: #F0F5F2; /* Soft mint green background */
            --bg-secondary: #FFFFFF; /* White cards */
            --text-primary: #2F3D37; /* Dark olive green */
            --text-secondary: #586A61;
            --text-tertiary: #8FA39A;
            --accent-primary: #4A5C52; /* Darker olive for buttons */
            --accent-secondary: #D4E0DB;
            --border-color: #E1EBE6;
            --accent-red: #e53e3e;
        }
        body {
            font-family: 'Inter', 'Noto Sans KR', sans-serif;
            background-color: var(--bg-primary);
            color: var(--text-primary);
        }
        .studio-container { background: var(--bg-primary); }
        .main-content { position: relative; z-index: 1; }
        .video-glow { box-shadow: 0 10px 30px -10px rgba(74, 92, 82, 0.3); border: 1px solid var(--border-color); }
        .btn-primary { 
            background: var(--accent-primary); 
            color: white;
            transition: all 0.3s ease; 
            border-radius: 8px; 
            font-weight: 500;
        }
        .btn-primary:hover { background-color: #3d4c44; }
        .btn-primary:disabled { background-color: #aeb8b3; cursor: not-allowed; }

        .btn-secondary { 
            background-color: white;
            color: var(--accent-primary);
            border: 1px solid var(--accent-secondary); 
            transition: all 0.3s ease; 
            border-radius: 8px;
            font-weight: 500;
        }
        .btn-secondary:hover { background-color: #F8FBF9; }
        .control-btn {
            background-color: white;
            border: 1px solid var(--border-color);
            border-radius: 9999px;
            padding: 0.75rem;
            transition: all 0.2s ease-in-out;
            color: var(--text-secondary);
        }
        .control-btn:disabled { background-color: #f0f0f0; cursor: not-allowed; color: #ccc; }
        .control-btn:hover:not(:disabled) { background-color: var(--bg-primary); transform: scale(1.05); }

        .loader {
            border: 4px solid var(--accent-secondary); border-left-color: var(--accent-primary);
            border-radius: 50%; width: 50px; height: 50px;
            animation: spin 1s linear infinite;
        }
        @keyframes spin { to { transform: rotate(360deg); } }
        .report-card {
            background-color: var(--bg-secondary);
            border: 1px solid var(--border-color);
            border-radius: 16px;
            box-shadow: 0 4px 15px rgba(0,0,0,0.05);
        }
        .modal-backdrop { background-color: rgba(0, 0, 0, 0.6); backdrop-filter: blur(8px); }
        .countdown-overlay {
            position: absolute; top: 0; left: 0; right: 0; bottom: 0;
            background-color: rgba(0,0,0,0.7); display: flex; align-items: center; justify-content: center;
            font-size: 8rem; font-weight: bold; color: white; z-index: 20; opacity: 0;
            transition: opacity 0.3s ease-in-out; pointer-events: none;
        }
        .countdown-overlay.visible { opacity: 1; pointer-events: auto; }
        .acti-logo {
            width: 48px; height: 48px; 
            border-radius: 12px;
            object-fit: cover;
        }
        .accordion-header { cursor: pointer; transition: background-color 0.2s ease; border-radius: 8px; }
        .accordion-header:hover { background-color: var(--bg-primary); }
        .accordion-content { max-height: 0; overflow: hidden; transition: max-height 0.8s ease-in-out; }
        details[open] .accordion-content { max-height: 2000px; }
        .accordion-arrow { transition: transform 0.3s ease; }
        details[open] summary .accordion-arrow { transform: rotate(90deg); }
        .coaching-card { 
            background: var(--bg-primary);
            border: 1px solid var(--border-color);
            border-radius: 12px;
        }
        .action-btn {
            background-color: white;
            border: 1px solid var(--border-color);
            color: var(--text-secondary);
            transition: all 0.2s ease;
        }
        .action-btn:hover {
            background-color: var(--bg-primary);
            color: var(--text-primary);
        }
        /* Teleprompter Styles */
        .teleprompter-overlay {
            position: absolute;
            top: 0; left: 0; right: 0; bottom: 0;
            background-color: rgba(0, 0, 0, 0.7);
            color: white;
            font-weight: 500;
            line-height: 1.8;
            z-index: 10;
            transition: opacity 0.3s ease;
            display: flex;
            align-items: center;
            justify-content: center;
            pointer-events: none;
        }
        .teleprompter-content {
            height: 100%;
            width: 100%;
            overflow: hidden;
            display: flex;
            justify-content: center;
        }
        .teleprompter-text {
            transition: transform 1s linear;
            width: 80%;
        }
        .unified-control-panel {
            display: flex;
            align-items: center;
            justify-content: space-between;
            gap: 1rem;
            width: 100%;
        }
    </style>
</head>
<body class="antialiased">
    <div id="app" class="studio-container relative min-h-screen w-full flex flex-col items-center p-4 md:p-8">
        <div class="main-content w-full max-w-4xl">
            <header class="text-left mb-6 md:mb-10 flex flex-row items-center justify-center space-x-4">
                <img src="audition2.png" alt="AcTi Logo" class="acti-logo">
                <div>
                    <h1 class="text-2xl md:text-3xl font-bold tracking-tight text-text-primary">AcTi Live Audition</h1>
                    <p id="actingTip" class="text-sm text-text-secondary"></p>
                </div>
            </header>

            <main id="rehearsalStage">
                <div id="videoAndControls" class="flex flex-col items-center">
                    <!-- Unified Control Panel -->
                    <div id="unifiedControls" class="report-card p-3 mb-4 w-full hidden">
                        <div class="unified-control-panel">
                            <div class="flex items-center space-x-2">
                                <label for="teleprompterToggle" class="text-sm font-medium text-text-primary">텔레프롬프터</label>
                                <div class="relative inline-block w-10 align-middle select-none transition duration-200 ease-in">
                                    <input type="checkbox" name="teleprompterToggle" id="teleprompterToggle" class="toggle-checkbox absolute block w-6 h-6 rounded-full bg-white border-4 appearance-none cursor-pointer"/>
                                    <label for="teleprompterToggle" class="toggle-label block overflow-hidden h-6 rounded-full bg-gray-300 cursor-pointer"></label>
                                </div>
                                <style>.toggle-checkbox:checked { right: 0; border-color: #4A5C52; } .toggle-checkbox:checked + .toggle-label { background-color: #4A5C52; }</style>
                            </div>

                            <div id="teleprompterSettings" class="hidden sm:flex items-center space-x-4">
                                <div class="flex items-center space-x-2">
                                    <button id="decreaseFontSize" class="p-2 btn-secondary rounded-full" aria-label="글자 작게">
                                        <svg xmlns="http://www.w3.org/2000/svg" class="h-5 w-5" viewBox="0 0 20 20" fill="currentColor">
                                          <path fill-rule="evenodd" d="M5 10a1 1 0 011-1h8a1 1 0 110 2H6a1 1 0 01-1-1z" clip-rule="evenodd" />
                                        </svg>
                                    </button>
                                    <button id="increaseFontSize" class="p-2 btn-secondary rounded-full" aria-label="글자 크게">
                                        <svg xmlns="http://www.w3.org/2000/svg" class="h-5 w-5" viewBox="0 0 20 20" fill="currentColor">
                                          <path fill-rule="evenodd" d="M10 5a1 1 0 011 1v3h3a1 1 0 110 2h-3v3a1 1 0 11-2 0v-3H6a1 1 0 110-2h3V6a1 1 0 011-1z" clip-rule="evenodd" />
                                        </svg>
                                    </button>
                                </div>
                                <div class="flex items-center space-x-2">
                                   <input type="range" id="scrollSpeed" min="1" max="20" value="5" class="w-24">
                                   <button id="previewScrollBtn" class="text-xs btn-secondary px-2 py-1">미리보기</button>
                                </div>
                            </div>

                            <div class="flex items-center space-x-2">
                                <button id="switchCameraBtn" class="control-btn" style="display: none;" aria-label="카메라 전환">
                                    <svg class="w-7 h-7" fill="none" stroke="currentColor" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M4 4v5h5M20 20v-5h-5M4 20h5v-5M20 4h-5v5"></path><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M15 4h5v5M9 20H4v-5M15 20h5v-5M9 4H4v5"></path></svg>
                                </button>
                                <button id="startRehearsalBtn" class="control-btn text-green-500" aria-label="리허설 시작"></button>
                                <button id="stopRehearsalBtn" class="control-btn text-red-500 hidden" aria-label="분석 중지"></button>
                                <button id="helpBtn" class="control-btn text-blue-500" aria-label="도움말">
                                    <svg class="w-7 h-7" fill="none" stroke="currentColor" viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M8.228 9c.549-1.165 2.03-2 3.772-2 2.21 0 4 1.343 4 3 0 1.4-1.278 2.575-3.006 2.907-.542.104-.994.546-.994 1.093m0 3h.01M21 12a9 9 0 11-18 0 9 9 0 0118 0z"></path></svg>
                                </button>
                            </div>
                        </div>
                    </div>

                    <div class="relative w-full">
                        <div id="videoContainer" class="mb-6 bg-black rounded-xl overflow-hidden aspect-video w-full">
                            <div id="setupMessage" class="w-full h-full flex flex-col items-center justify-center space-y-4 p-4 text-center">
                                <p class="text-lg text-white">어떻게 시작할까요?</p>
                                <div class="flex flex-col sm:flex-row space-y-2 sm:space-y-0 sm:space-x-4">
                                    <button id="startLiveBtn" class="px-6 py-3 font-semibold btn-primary">라이브 카메라 시작</button>
                                    <button id="uploadVideoBtn" class="px-6 py-3 font-semibold btn-secondary">영상 파일 업로드</button>
                                </div>
                                <input type="file" id="videoFileInput" class="hidden" accept="video/*">
                            </div>
                            <video id="videoFeed" playsinline class="w-full h-full object-cover hidden"></video>
                            <div id="countdown" class="countdown-overlay"></div>
                            <div id="teleprompterOverlay" class="teleprompter-overlay opacity-0 pointer-events-none">
                                <div class="teleprompter-content">
                                    <div id="teleprompterText" class="teleprompter-text whitespace-pre-line"></div>
                                </div>
                            </div>
                        </div>
                    </div>
                    
                    <div id="controls" class="hidden report-card p-4 w-full">
                        <div class="space-y-4">
                            <div>
                                <div class="flex justify-between items-center mb-2">
                                    <label for="scriptInput" class="block text-sm font-medium text-text-primary">대본 입력 (필수)</label>
                                    <div id="reformatSpinner" class="hidden w-4 h-4 border-2 border-gray-300 border-t-accent-primary rounded-full animate-spin"></div>
                                </div>
                                <textarea id="scriptInput" rows="5" class="w-full bg-white border border-gray-300 rounded-lg p-3 text-text-primary focus:ring-2 focus:ring-accent-primary focus:border-accent-primary transition" placeholder="여기에 대본을 입력하거나 파일을 업로드하세요."></textarea>
                            </div>
                            
                            <div>
                                <label for="contextInput" class="block text-sm font-medium text-text-primary mb-2">대본 상황설명 (선택사항)</label>
                                <textarea id="contextInput" rows="2" class="w-full bg-white border border-gray-300 rounded-lg p-3 text-text-primary focus:ring-2 focus:ring-accent-primary focus:border-accent-primary transition" placeholder="예: 이 장면은 스케치 코미디 형식으로 장소는 엘리베이터 안이다."></textarea>
                            </div>

                            <div>
                                <input type="file" id="fileInput" class="hidden" accept=".pdf,.txt,.srt,image/*">
                                <button id="uploadBtn" class="w-full px-4 py-2 text-sm font-semibold btn-secondary flex items-center justify-center space-x-2">
                                    <svg class="w-5 h-5" fill="none" stroke="currentColor" viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M4 16v1a3 3 0 003 3h10a3 3 0 003-3v-1m-4-8l-4-4m0 0L8 8m4-4v12"></path></svg>
                                    <span>파일 업로드 (PDF, TXT, SRT, 이미지)</span>
                                </button>
                            </div>
                        </div>
                    </div>
                </div>
            </main>

            <div id="loading" class="hidden text-center py-10">
                <div class="loader mx-auto"></div>
                <p id="loadingText" class="mt-4 text-lg text-text-secondary">AcTi가 당신의 연기를 분석하고 있습니다...</p>
                <p class="text-sm text-text-tertiary">캐스팅 디렉터의 시선으로 종합 평가 시트를 생성합니다.</p>
            </div>

            <section id="feedbackReport" class="hidden space-y-6">
            </section>
        </div>

        <div id="helpModal" class="fixed inset-0 z-50 flex items-center justify-center p-4 modal-backdrop hidden"> 
            <div class="report-card p-6 w-full max-w-lg text-text-primary"> 
                <div class="flex justify-between items-center mb-4"> <h3 class="font-bold text-xl" style="color: var(--accent-primary);">AcTi Live Audition 사용법</h3> <button id="closeHelpModalBtn" class="text-2xl font-bold text-text-tertiary hover:text-text-primary">&times;</button> </div> 
                <div class="space-y-4 text-left"> <div class="flex items-start"> <div class="flex-shrink-0 w-8 h-8 rounded-full bg-accent-primary flex items-center justify-center font-bold text-white mr-4">1</div> <div> <h4 class="font-semibold">리허설 준비</h4> <p class="text-sm text-text-secondary">카메라/마이크를 허용하고, 대본과 상황 설명을 입력하거나 업로드합니다.</p> </div> </div> <div class="flex items-start"> <div class="flex-shrink-0 w-8 h-8 rounded-full bg-accent-primary flex items-center justify-center font-bold text-white mr-4">2</div> <div> <h4 class="font-semibold">텔레프롬프터 사용 (선택)</h4> <p class="text-sm text-text-secondary">컨트롤 패널에서 텔레프롬프터를 켜고 '미리보기'로 자신에게 맞는 속도를 조절하세요.</p> </div> </div><div class="flex items-start"> <div class="flex-shrink-0 w-8 h-8 rounded-full bg-accent-primary flex items-center justify-center font-bold text-white mr-4">3</div> <div> <h4 class="font-semibold">리허설 시작</h4> <p class="text-sm text-text-secondary">컨트롤 패널의 시작 아이콘(▶)을 누르면 10초 카운트다운 후 퍼포먼스 분석이 시작됩니다.</p> </div> </div> <div class="flex items-start"> <div class="flex-shrink-0 w-8 h-8 rounded-full bg-accent-primary flex items-center justify-center font-bold text-white mr-4">4</div> <div> <h4 class="font-semibold">분석 및 평가</h4> <p class="text-sm text-text-secondary">중지 아이콘(■)을 누르면 AI가 퍼포먼스와 대본을 종합 분석하여 오디션 평가 시트를 생성합니다.</p> </div> </div> <div class="flex items-start"> <div class="flex-shrink-0 w-8 h-8 rounded-full bg-accent-primary flex items-center justify-center font-bold text-white mr-4">5</div> <div> <h4 class="font-semibold">리포트 확인</h4> <p class="text-sm text-text-secondary">생성된 평가 시트의 강점/보완점과 감독 총평을 통해 연기를 발전시키세요.</p> </div> </div> </div> 
            </div> 
        </div>
        <div id="notification" class="fixed top-5 right-5 bg-red-600 text-white px-6 py-3 rounded-lg shadow-lg opacity-0 transition-all duration-300 z-50 pointer-events-none"></div>
    </div>

    <script>
        document.addEventListener('DOMContentLoaded', () => {
            pdfjsLib.GlobalWorkerOptions.workerSrc = 'https://cdnjs.cloudflare.com/ajax/libs/pdf.js/2.11.338/pdf.worker.min.js';

            const videoFeed = document.getElementById('videoFeed');
            const videoContainer = document.getElementById('videoContainer');
            const setupMessage = document.getElementById('setupMessage');
            const startLiveBtn = document.getElementById('startLiveBtn');
            const uploadVideoBtn = document.getElementById('uploadVideoBtn');
            const videoFileInput = document.getElementById('videoFileInput');
            const controls = document.getElementById('controls');
            const unifiedControls = document.getElementById('unifiedControls'); 
            const rehearsalStage = document.getElementById('rehearsalStage');
            const feedbackReport = document.getElementById('feedbackReport');
            const loading = document.getElementById('loading');
            const loadingText = document.getElementById('loadingText');
            const startRehearsalBtn = document.getElementById('startRehearsalBtn');
            const stopRehearsalBtn = document.getElementById('stopRehearsalBtn');
            const switchCameraBtn = document.getElementById('switchCameraBtn');
            const scriptInput = document.getElementById('scriptInput');
            const contextInput = document.getElementById('contextInput');
            const notification = document.getElementById('notification');
            const actingTip = document.getElementById('actingTip');
            const helpBtn = document.getElementById('helpBtn');
            const helpModal = document.getElementById('helpModal');
            const closeHelpModalBtn = document.getElementById('closeHelpModalBtn');
            const countdown = document.getElementById('countdown');
            const uploadBtn = document.getElementById('uploadBtn');
            const fileInput = document.getElementById('fileInput');
            const reformatSpinner = document.getElementById('reformatSpinner');
            const teleprompterToggle = document.getElementById('teleprompterToggle');
            const teleprompterSettings = document.getElementById('teleprompterSettings');
            const teleprompterOverlay = document.getElementById('teleprompterOverlay');
            const teleprompterText = document.getElementById('teleprompterText');
            const increaseFontSizeBtn = document.getElementById('increaseFontSize');
            const decreaseFontSizeBtn = document.getElementById('decreaseFontSize');
            const scrollSpeedSlider = document.getElementById('scrollSpeed');
            const previewScrollBtn = document.getElementById('previewScrollBtn');

            let mediaStream, audioContext, analyser, dataArray, source, motionContext, lastImageData;
            let performanceData = { volume: [], motion: [] };
            let analysisLoopId, teleprompterIntervalId;
            let currentFontSize = 24;
            let isTeleprompterPreviewing = false;
            let isLiveMode = true;
            let videoDevices = [];
            let currentVideoDeviceIndex = 0;
            
            const userApiKey = 'AIzaSyBbEsfDqt5ojPAJoo70Nozro4LacKk__4k';
            
            const startIconSVG = `<svg class="w-7 h-7" viewBox="0 0 24 24" fill="currentColor"><path d="M8 5v14l11-7z"/></svg>`;
            const stopIconSVG = `<svg class="w-7 h-7" viewBox="0 0 24 24" fill="currentColor"><path d="M6 6h12v12H6z"/></svg>`;
            startRehearsalBtn.innerHTML = startIconSVG;
            stopRehearsalBtn.innerHTML = stopIconSVG;

            function initializeApp() {
                actingTip.textContent = "배우 오디션 실전 마스터";
                teleprompterText.style.fontSize = `${currentFontSize}px`;
                startRehearsalBtn.disabled = true;
                // For mobile browser audio policies
                document.body.addEventListener('click', initAudioContext, { once: true });
                document.body.addEventListener('touchstart', initAudioContext, { once: true });
            }
            
            function initAudioContext() {
                if (!audioContext) {
                    audioContext = new (window.AudioContext || window.webkitAudioContext)();
                    analyser = audioContext.createAnalyser();
                    analyser.fftSize = 256;
                    const bufferLength = analyser.frequencyBinCount;
                    dataArray = new Uint8Array(bufferLength);
                    console.log('AudioContext initialized by user interaction.');
                }
            }

            function showNotification(message, isError = false, duration = 3000) {
                notification.textContent = message;
                notification.classList.remove('opacity-0');
                notification.classList.add(isError ? 'bg-accent-red' : 'bg-green-500');
                notification.classList.remove(isError ? 'bg-green-500' : 'bg-accent-red');

                setTimeout(() => {
                    notification.classList.add('opacity-0');
                }, duration);
            }

            function setupForAnalysis() {
                setupMessage.classList.add('hidden');
                videoFeed.classList.remove('hidden');
                videoContainer.classList.add('video-glow');
                controls.classList.remove('hidden');
                unifiedControls.classList.remove('hidden');
            }
            
            async function setupCamera(deviceId = null) {
                isLiveMode = true;
                if (mediaStream) {
                    mediaStream.getTracks().forEach(track => track.stop());
                }
                
                try {
                    // Check if AudioContext was pre-initialized by user interaction
                    initAudioContext();

                    if (videoDevices.length === 0) {
                        const devices = await navigator.mediaDevices.enumerateDevices();
                        videoDevices = devices.filter(device => device.kind === 'videoinput');
                        if (videoDevices.length === 0) throw new Error("No camera found.");
                    }

                    switchCameraBtn.style.display = videoDevices.length > 1 ? 'block' : 'none';
                    
                    const currentDeviceId = deviceId || videoDevices[currentVideoDeviceIndex].deviceId;
                    
                    const constraints = {
                        video: { deviceId: { exact: currentDeviceId } },
                        audio: true
                    };
                    
                    mediaStream = await navigator.mediaDevices.getUserMedia(constraints);
                    videoFeed.srcObject = mediaStream;
                    videoFeed.muted = true;
                    try {
                        await videoFeed.play();
                    } catch (err) {
                        if (err.name !== 'AbortError') { throw err; }
                        console.log("Live video play was interrupted.");
                    }

                    setupForAnalysis();
                    
                    source = audioContext.createMediaStreamSource(mediaStream);
                    source.connect(analyser);

                    videoFeed.onloadedmetadata = () => {
                        const motionCanvas = document.createElement('canvas');
                        motionCanvas.width = videoFeed.videoWidth / 8;
                        motionCanvas.height = videoFeed.videoHeight / 8;
                        motionContext = motionCanvas.getContext('2d', { willReadFrequently: true });
                    };
                } catch (error) {
                    console.error("카메라/마이크 접근 오류:", error.name, error.message);
                    let userMessage = '카메라/마이크 접근 중 오류가 발생했습니다.';
                    if(error.name === 'NotAllowedError') {
                        userMessage = '카메라/마이크 사용 권한이 거부되었습니다. 브라우저 설정을 확인해주세요.';
                    } else if(error.name === 'NotFoundError') {
                        userMessage = '연결된 카메라나 마이크를 찾을 수 없습니다.';
                    }
                    
                    let errorMessage = `<p class="text-red-500 font-semibold">${userMessage}</p><div class="flex space-x-4 mt-4"><button id="retrySetup" class="px-6 py-2 font-semibold btn-secondary">다시 시도</button></div>`;
                    setupMessage.innerHTML = errorMessage;
                    document.getElementById('retrySetup')?.addEventListener('click', () => {
                        setupMessage.innerHTML = `<p class="text-lg text-white">어떻게 시작할까요?</p><div class="flex flex-col sm:flex-row space-y-2 sm:space-y-0 sm:space-x-4"><button id="startLiveBtn" class="px-6 py-3 font-semibold btn-primary">라이브 카메라 시작</button><button id="uploadVideoBtn" class="px-6 py-3 font-semibold btn-secondary">영상 파일 업로드</button></div><input type="file" id="videoFileInput" class="hidden" accept="video/*">`;
                        document.getElementById('startLiveBtn').addEventListener('click', () => setupCamera());
                        document.getElementById('uploadVideoBtn').addEventListener('click', () => videoFileInput.click());
                    });
                }
            }

            async function switchCamera() {
                if (videoDevices.length < 2) return;
                currentVideoDeviceIndex = (currentVideoDeviceIndex + 1) % videoDevices.length;
                await setupCamera(videoDevices[currentVideoDeviceIndex].deviceId);
            }

            function handleVideoUpload(event) {
                const file = event.target.files[0];
                if (!file) return;

                isLiveMode = false;
                switchCameraBtn.style.display = 'none';
                const videoURL = URL.createObjectURL(file);
                videoFeed.srcObject = null;
                videoFeed.src = videoURL;
                videoFeed.muted = false;

                setupForAnalysis();
                
                initAudioContext();

                videoFeed.oncanplay = () => {
                    try {
                        source = audioContext.createMediaElementSource(videoFeed);
                        source.connect(analyser);
                        analyser.connect(audioContext.destination);
                    } catch (e) {
                        console.error("Error connecting audio source:", e);
                        showNotification("오디오 분석을 시작할 수 없습니다.", true);
                        return;
                    }
                }
                
                videoFeed.onloadedmetadata = () => {
                    const motionCanvas = document.createElement('canvas');
                    motionCanvas.width = videoFeed.videoWidth;
                    motionCanvas.height = videoFeed.videoHeight;
                    motionContext = motionCanvas.getContext('2d', { willReadFrequently: true });
                };

                videoFeed.onended = () => {
                    if (!stopRehearsalBtn.classList.contains('hidden')) {
                        stopAndAnalyze();
                    }
                };
            }
            
            function playTickSound() {
                if (!audioContext) return;
                const now = audioContext.currentTime;
                const oscillator = audioContext.createOscillator();
                const gainNode = audioContext.createGain();
                oscillator.type = 'sine';
                oscillator.frequency.setValueAtTime(1200, now);
                gainNode.gain.setValueAtTime(0, now);
                gainNode.gain.linearRampToValueAtTime(0.15, now + 0.01);
                gainNode.gain.linearRampToValueAtTime(0, now + 0.1);
                oscillator.connect(gainNode);
                gainNode.connect(audioContext.destination);
                oscillator.start(now);
                oscillator.stop(now + 0.1);
            }
            
            function waitForAudioData() {
                return new Promise((resolve, reject) => {
                    loadingText.textContent = "마이크 신호 확인 중...";
                    const checkInterval = 100; // Check every 0.1s
                    const timeout = 3000; // Fail after 3s
                    let elapsedTime = 0;
                    let consecutiveSuccess = 0;

                    const check = () => {
                        if (!analyser || !dataArray) {
                            reject(new Error("Audio analyzer not ready."));
                            return;
                        }

                        analyser.getByteFrequencyData(dataArray);
                        const sum = dataArray.reduce((a, b) => a + b, 0);

                        if (sum > 0) {
                            consecutiveSuccess++;
                            // Consider it stable after 2 consecutive successful checks
                            if (consecutiveSuccess >= 2) {
                                console.log("Audio signal detected. Starting analysis.");
                                loadingText.textContent = "AcTi가 당신의 연기를 분석하고 있습니다...";
                                resolve();
                                return;
                            }
                        } else {
                            consecutiveSuccess = 0; // Reset if signal drops
                        }
                        
                        elapsedTime += checkInterval;
                        if (elapsedTime >= timeout) {
                            console.error("Audio signal timeout.");
                            reject(new Error("마이크에서 음성 신호를 감지할 수 없습니다. 마이크 연결을 확인해주세요."));
                            return;
                        }
                        setTimeout(check, checkInterval);
                    };
                    check();
                });
            }


            async function startPerformanceAnalysis() {
                if (!audioContext || audioContext.state === 'closed') {
                    showNotification("오디오 시스템 오류. 페이지를 새로고침 해주세요.", true);
                    return;
                }
                
                performanceData = { volume: [], motion: [] };

                function analysisLoop() {
                    if (analyser && dataArray) {
                        analyser.getByteFrequencyData(dataArray);
                        let sum = dataArray.reduce((a, b) => a + b, 0);
                        performanceData.volume.push(sum / dataArray.length);
                    }

                    if (motionContext && videoFeed.readyState >= 2) {
                        motionContext.drawImage(videoFeed, 0, 0, motionContext.canvas.width, motionContext.canvas.height);
                        const currentImageData = motionContext.getImageData(0, 0, motionContext.canvas.width, motionContext.canvas.height).data;
                        if (lastImageData) {
                            let diff = 0;
                            for (let i = 0; i < currentImageData.length; i += 4) {
                                diff += Math.abs(currentImageData[i] - lastImageData[i]) + Math.abs(currentImageData[i+1] - lastImageData[i+1]) + Math.abs(currentImageData[i+2] - lastImageData[i+2]);
                            }
                            performanceData.motion.push(diff / (currentImageData.length * 0.75));
                        }
                        lastImageData = new Uint8ClampedArray(currentImageData);
                    }
                    analysisLoopId = requestAnimationFrame(analysisLoop);
                }
                analysisLoop();
            }

            function stopPerformanceAnalysis() {
                if(analysisLoopId) cancelAnimationFrame(analysisLoopId);
                stopTeleprompterScroll();
            }

            async function startRehearsal() {
                if (isTeleprompterPreviewing) {
                    toggleTeleprompterPreview(); 
                }
                startRehearsalBtn.disabled = true;

                const startTheShow = async () => {
                    try {
                        // Re-initialize audio context if closed
                        if (!audioContext || audioContext.state === 'closed') {
                            initAudioContext();
                        }
                        // Resume audio context
                        if (audioContext && audioContext.state === 'suspended') {
                           await audioContext.resume();
                        }
                        
                        // Start playing if it's a video file
                        if(!isLiveMode) {
                            try {
                                await videoFeed.play();
                            } catch (err) {
                                if (err.name !== 'AbortError') {
                                    throw err;
                                }
                                console.log("Video play was interrupted. This is normal.");
                            }
                        }

                        // Wait for mic signal (only in live mode)
                        if (isLiveMode) {
                            await waitForAudioData();
                        }

                        // Change UI and start analysis
                        startRehearsalBtn.classList.add('hidden');
                        stopRehearsalBtn.classList.remove('hidden');
                        scriptInput.disabled = true;
                        contextInput.disabled = true;
                        uploadBtn.disabled = true;
                        if(teleprompterToggle.checked) startTeleprompterScroll(false);
                        startPerformanceAnalysis();
                        startRehearsalBtn.disabled = false;

                    } catch(error) {
                        showNotification(error.message, true, 5000);
                        console.error("Failed to start rehearsal:", error);
                        // Reset rehearsal state on failure
                        stopRehearsalBtn.classList.add('hidden');
                        startRehearsalBtn.classList.remove('hidden');
                        startRehearsalBtn.disabled = false;
                        loadingText.textContent = "AcTi가 당신의 연기를 분석하고 있습니다...";
                    }
                }

                if (isLiveMode) {
                    let count = 10;
                    countdown.textContent = count;
                    countdown.classList.add('visible');
                    playTickSound();
                    const timer = setInterval(() => {
                        count--;
                        countdown.textContent = count > 0 ? count : '▶';
                        if (count >= 0) playTickSound();
                        
                        if (count < 0) {
                            clearInterval(timer);
                            countdown.classList.remove('visible');
                            startTheShow();
                        }
                    }, 1000);
                } else {
                    startTheShow();
                }
            }

            async function stopAndAnalyze() {
                stopPerformanceAnalysis();
                if(!isLiveMode && videoFeed) videoFeed.pause();
                rehearsalStage.classList.add('hidden');
                loading.classList.remove('hidden');
                
                try {
                    const script = scriptInput.value.trim();
                    const context = contextInput.value.trim();
                    let scriptAnalysisResult = null;

                    if (script) {
                        loadingText.textContent = "1/2: 대본 심층 분석 중...";
                        scriptAnalysisResult = await getScriptAnalysis(script, context);
                    }
                    
                    loadingText.textContent = "2/2: 퍼포먼스 평가 중...";
                    const performanceAnalysisResult = await getPerformanceAnalysis(script, context, performanceData, scriptAnalysisResult);
                    
                    displayAuditionSheet(performanceAnalysisResult, scriptAnalysisResult);
                    feedbackReport.classList.remove('hidden');

                } catch (error) {
                    console.error("AcTi 분석 오류:", error);
                    showNotification(`분석 중 오류가 발생했습니다: ${error.message}`, true, 5000);
                    resetForNewRehearsal();
                } finally {
                    loading.classList.add('hidden');
                    loadingText.textContent = "AcTi가 당신의 연기를 분석하고 있습니다...";
                }
            }

            function resetForNewRehearsal() {
                if (isTeleprompterPreviewing) {
                    toggleTeleprompterPreview();
                }
                feedbackReport.innerHTML = '';
                feedbackReport.classList.add('hidden');
                rehearsalStage.classList.remove('hidden');
                unifiedControls.classList.add('hidden');
                controls.classList.add('hidden');
                videoFeed.classList.add('hidden');
                videoFeed.src = '';
                videoFeed.srcObject = null;
                
                // Restore the initial setup screen and re-bind events
                setupMessage.innerHTML = `
                    <p class="text-lg text-white">어떻게 시작할까요?</p>
                    <div class="flex flex-col sm:flex-row space-y-2 sm:space-y-0 sm:space-x-4">
                        <button id="startLiveBtn" class="px-6 py-3 font-semibold btn-primary">라이브 카메라 시작</button>
                        <button id="uploadVideoBtn" class="px-6 py-3 font-semibold btn-secondary">영상 파일 업로드</button>
                    </div>
                    <input type="file" id="videoFileInput" class="hidden" accept="video/*">
                `;
                document.getElementById('startLiveBtn').addEventListener('click', () => setupCamera());
                document.getElementById('uploadVideoBtn').addEventListener('click', () => document.getElementById('videoFileInput').click());
                document.getElementById('videoFileInput').addEventListener('change', handleVideoUpload);
                setupMessage.classList.remove('hidden');


                stopRehearsalBtn.classList.add('hidden');
                startRehearsalBtn.classList.remove('hidden');
                startRehearsalBtn.disabled = true;
                scriptInput.disabled = false;
                contextInput.disabled = false;
                uploadBtn.disabled = false;
                scriptInput.value = '';
                contextInput.value = '';
                updateTeleprompterText();
                isLiveMode = true;
                if (audioContext && audioContext.state !== 'closed') {
                    audioContext.close().then(() => {
                        audioContext = null;
                        document.body.addEventListener('click', initAudioContext, { once: true });
                        document.body.addEventListener('touchstart', initAudioContext, { once: true });
                    });
                } else {
                     document.body.addEventListener('click', initAudioContext, { once: true });
                     document.body.addEventListener('touchstart', initAudioContext, { once: true });
                }
            }

            async function getScriptAnalysis(script, context) {
                const systemPrompt = `You are 'AcTi', a world-class acting coach, screenwriter, and director AI. Your analysis must be detailed, insightful, and professional, providing a sincere and deep guide for an actor. Analyze the script deeply and provide your insights in the specified JSON format. Your primary focus is on the writer's intent and the script's core elements.
                
                - **General**: ALL text output MUST be in Korean. Do not use any markdown formatting like **.`;
                const userQuery = `Analyze this script and provide a deep analysis of its core components. Consider the following context provided by the actor:\n\n[Actor's Context]\n${context || '제공되지 않음'}\n\n[Script]\n---\n${script}\n---`;
                const payload = {
                    contents: [{ parts: [{ text: userQuery }] }],
                    systemInstruction: { parts: [{ text: systemPrompt }] },
                    generationConfig: {
                        responseMimeType: "application/json",
                        responseSchema: {type: 'OBJECT', properties: { sceneOverview: {type: 'OBJECT', properties: { sceneFunction: { type: 'STRING' }, conflictSummary: { type: 'STRING' }}}, directorsView: {type: 'OBJECT', properties: {writerIntent: { type: 'STRING' }, coreTheme: { type: 'STRING' }}}}}
                    }
                };
                const result = await callGeminiAPI(payload);
                return JSON.parse(result.candidates[0].content.parts[0].text);
            }

            async function getPerformanceAnalysis(script, context, performance, scriptAnalysis) {
                const isScriptless = !script.trim();
                
                const voiceAnalysis = analyzeData(performance.volume, true);
                const motionAnalysis = analyzeData(performance.motion, false);

                let performanceSummary = `[Performance Data]
Voice Analysis:
- Activity Level: ${voiceAnalysis.isDataPresent ? 'Active' : 'Inactive'}
- Average Volume (0-100): ${voiceAnalysis.mean.toFixed(1)}
- Volume Dynamics (0-50): ${voiceAnalysis.stdDev.toFixed(1)} (A higher value means more dynamic, less monotone)
- Peak Volume (0-100): ${voiceAnalysis.peak.toFixed(1)}
- Silence Percentage: ${voiceAnalysis.silenceRatio.toFixed(1)}%

Motion Analysis:
- Activity Level: ${motionAnalysis.isDataPresent ? 'Active' : 'Inactive'}
- Average Motion (0-100): ${motionAnalysis.mean.toFixed(1)}
`;
                
                const systemPrompt = `You are 'AcTi', a world-class acting coach and casting director AI. Your task is to provide a detailed, qualitative analysis based on the provided performance metrics. Your voice should be that of an insightful, professional director giving feedback to an actor.

[Core Principles]
1.  **NEVER MENTION TECHNICAL DATA:** Your final feedback to the actor MUST NOT contain any technical terms or numbers from the performance data. Do not mention 'volume', 'dynamics', 'peak volume', 'silence percentage', 'motion average', or any numerical values.
2.  **TRANSLATE DATA INTO ACTING CRITIQUE:** Use the provided data as an internal reference to inform your qualitative analysis. For example:
    * Low 'Average Volume' could be translated to "목소리가 작아 대사 전달력이 아쉬웠습니다." (Your voice was quiet, which hindered line delivery.)
    * High 'Volume Dynamics' could become "감정의 기복을 목소리 톤에 잘 담아냈습니다." (You effectively conveyed emotional fluctuations through your vocal tone.)
    * High 'Silence Percentage' could be interpreted as "대사 사이의 '쉼'을 효과적으로 사용하여 긴장감을 조성했습니다." (You used pauses between lines effectively to build tension.)
3.  **FOCUS ON THE PERFORMANCE:** Your entire feedback should be about the acting itself—character interpretation, emotional expression, pacing, rhythm, and delivery. Speak like a director, not a technician.
4.  **COACHING PIVOT:** If 'Activity Level' is 'Inactive' (meaning no data), state that analysis is impossible and offer general coaching advice based on the script for a future take.

[Other Rules]
- All text in Korean. No markdown.
- Adhere to the strict JSON schema.
- All scores must be integers from 0 to 5.`;

                const userPrompt = `Based on the script, actor's context, and the detailed performance data below, generate a comprehensive audition evaluation sheet. Strictly follow all rules in your system prompt, especially the Metric-to-Skill Translation principle.\n\n[Script Analysis]\n${JSON.stringify(scriptAnalysis)}\n\n[Actor's Context]\n${context || 'Not provided'}\n\n[Detailed Performance Data]\n${performanceSummary}`;
                
                const feedbackFormat = { 
                    type: "OBJECT", 
                    properties: { 
                        category: { type: "STRING" },
                        problem: { type: "STRING" }, 
                        evidence: { type: "STRING" }, 
                        suggestion: { type: "STRING" } 
                    } 
                };
                const schema = {
                    type: "OBJECT",
                    properties: {
                        finalGrade: { type: "STRING" },
                        overallReview: { type: "STRING" },
                        rubricScores: { type: "ARRAY", items: { type: "OBJECT", properties: { axis: { type: "STRING" }, score: { type: "NUMBER" }, summary: { type: "STRING" } } } },
                        detailedBreakdown: {
                            type: "OBJECT",
                            properties: {
                                technicalControl: { type: "ARRAY", items: feedbackFormat },
                                emotionalAuthenticity: { type: "ARRAY", items: feedbackFormat },
                                interpretationAndCharacterization: { type: "ARRAY", items: feedbackFormat },
                                interactionAndListening: { type: "ARRAY", items: feedbackFormat },
                            }
                        },
                        onSetAlerts: { type: "ARRAY", items: {type: "OBJECT", properties: { alertType: {type: "STRING"}, directorChecklist: {type: "STRING"} } } },
                        grandCritique: {type: "STRING"}
                    }
                };
                if (isScriptless || !scriptAnalysis) {
                    delete schema.properties.detailedBreakdown.properties.interpretationAndCharacterization;
                }

                const payload = { systemInstruction: { parts: [{ text: systemPrompt }] }, contents: [{ parts: [{ text: userPrompt }] }], generationConfig: { responseMimeType: "application/json", responseSchema: schema } };
                
                const result = await callGeminiAPI(payload);
                return JSON.parse(result.candidates[0].content.parts[0].text);
            }
            
            async function callGeminiAPI(payload) {
                const API_URL = `https://generativelanguage.googleapis.com/v1beta/models/gemini-2.5-flash-preview-05-20:generateContent?key=${userApiKey}`;
                
                const response = await fetch(API_URL, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify(payload)
                });
                if (!response.ok) {
                   const errorBody = await response.json();
                   throw new Error(errorBody.error?.message || `API Error: ${response.status}`);
                }
                return response.json();
            }

            function displayAuditionSheet(performanceResult, scriptResult) {
                const { finalGrade, overallReview, rubricScores, detailedBreakdown, onSetAlerts, grandCritique } = performanceResult;

                if (!detailedBreakdown) {
                    showNotification("분석 결과에 오류가 있습니다 (detailedBreakdown 누락).", true);
                    return;
                }
                
                const gradeInfo = {
                    'A': { text: '즉시 캐스팅', color: 'bg-green-500 text-black', icon: `<svg class="w-5 h-5" viewBox="0 0 24 24" fill="currentColor"><path d="M12 2C6.48 2 2 6.48 2 12s4.48 10 10 10 10-4.48 10-10S17.52 2 12 2zm-2 15l-5-5 1.41-1.41L10 14.17l7.59-7.59L19 8l-9 9z"/></svg>`},
                    'B': { text: '콜백 대상', color: 'bg-blue-500 text-white', icon: `<svg class="w-5 h-5" viewBox="0 0 24 24" fill="currentColor"><path d="M12 4.5C7 4.5 2.73 7.61 1 12c1.73 4.39 6 7.5 11 7.5s9.27-3.11 11-7.5c-1.73-4.39-6-7.5-11-7.5zM12 17c-2.76 0-5-2.24-5-5s2.24-5 5-5 5 2.24 5 5-2.24 5-5 5zm0-8c-1.66 0-3 1.34-3 3s1.34 3 3 3 3-1.34 3-3-1.34-3-3-3z"/></svg>` },
                    'C': { text: '재코칭 필요', color: 'bg-yellow-400 text-black', icon: `<svg class="w-5 h-5" viewBox="0 0 24 24" fill="currentColor"><path d="M1 21h22L12 2 1 21zm12-3h-2v-2h2v2zm0-4h-2v-4h2v4z"/></svg>` }
                };

                const createCoachingCard = (item) => `
                    <div class="coaching-card p-4 rounded-lg mt-3">
                        <h5 class="font-semibold text-text-primary mb-3">${item.category}</h5>
                        <div class="space-y-2 text-sm">
                            <div class="flex items-start">
                                <span class="font-bold text-red-500 mr-2">[P]</span>
                                <p class="text-text-primary flex-1">${item.problem}</p>
                            </div>
                            <div class="flex items-start">
                                <span class="font-bold text-text-tertiary mr-2">[E]</span>
                                <p class="text-text-secondary flex-1">${item.evidence}</p>
                            </div>
                            <div class="flex items-start">
                                <span class="font-bold text-green-500 mr-2">[S]</span>
                                <p class="text-text-primary flex-1">${item.suggestion}</p>
                            </div>
                        </div>
                    </div>`;

                const createSectionHTML = (title, icon, data) => {
                    if (!data || data.length === 0) return '';
                    return `
                        <div class="report-card">
                            <details class="accordion-item" open>
                                <summary class="accordion-header flex justify-between items-center p-4 list-none">
                                    <div class="flex items-center space-x-3">
                                        <span class="text-2xl">${icon}</span>
                                        <h3 class="text-lg font-semibold text-text-primary">${title}</h3>
                                    </div>
                                    <svg class="accordion-arrow w-6 h-6 text-text-tertiary" fill="none" stroke="currentColor" viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M9 5l7 7-7 7"></path></svg>
                                </summary>
                                <div class="accordion-content px-4 pb-4">
                                    ${data.map(createCoachingCard).join('')}
                                </div>
                            </details>
                        </div>`;
                };
                
                const scriptAnalysisHTML = scriptResult ? `
                    <div class="report-card p-4 sm:p-6">
                        <h3 class="text-lg font-semibold text-accent-primary mb-4">대본 심층 분석</h3>
                        <div class="space-y-3">
                            <div class="coaching-card p-4">
                                <h4 class="font-semibold text-text-primary mb-1">장면의 목표와 기능</h4>
                                <p class="text-sm text-text-secondary">${scriptResult.sceneOverview.sceneFunction}</p>
                            </div>
                            <div class="coaching-card p-4">
                                <h4 class="font-semibold text-text-primary mb-1">핵심 갈등 구조</h4>
                                <p class="text-sm text-text-secondary">${scriptResult.sceneOverview.conflictSummary}</p>
                            </div>
                            <div class="coaching-card p-4">
                                <h4 class="font-semibold text-text-primary mb-1">작가의 의도</h4>
                                <p class="text-sm text-text-secondary">${scriptResult.directorsView.writerIntent}</p>
                            </div>
                            <div class="coaching-card p-4">
                                <h4 class="font-semibold text-text-primary mb-1">핵심 주제와 상징</h4>
                                <p class="text-sm text-text-secondary">${scriptResult.directorsView.coreTheme}</p>
                            </div>
                        </div>
                    </div>
                ` : '';

                const chartData = {
                    labels: (rubricScores || []).map(item => item.axis.split('·')[0]),
                    datasets: [{
                        label: '역량 평가',
                        data: (rubricScores || []).map(item => item.score),
                        backgroundColor: 'rgba(74, 92, 82, 0.2)',
                        borderColor: 'rgba(74, 92, 82, 1)',
                        pointBackgroundColor: 'rgba(74, 92, 82, 1)',
                        pointBorderColor: '#fff',
                        pointHoverBackgroundColor: '#fff',
                        pointHoverBorderColor: 'rgba(74, 92, 82, 1)',
                    }]
                };

                feedbackReport.innerHTML = `
                    <div class="flex flex-wrap justify-between items-center mb-6 gap-4">
                        <h2 class="text-2xl md:text-3xl font-bold">오디션 최종 평가 보고서</h2>
                        <div class="flex items-center space-x-2">
                           <button id="saveJpgBtn" title="JPG로 저장" class="action-btn p-2 rounded-lg"><svg class="w-5 h-5" fill="none" stroke="currentColor" viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M4 16l4.586-4.586a2 2 0 012.828 0L16 16m-2-2l1.586-1.586a2 2 0 012.828 0L20 14m-6-6h.01M6 20h12a2 2 0 002-2V6a2 2 0 00-2-2H6a2 2 0 00-2 2v12a2 2 0 002 2z"></path></svg></button>
                           <button id="savePdfBtn" title="PDF로 저장" class="action-btn p-2 rounded-lg"><svg class="w-5 h-5" fill="none" stroke="currentColor" viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M12 10v6m0 0l-3-3m3 3l3-3m2 8H7a2 2 0 01-2-2V5a2 2 0 012-2h5.586a1 1 0 01.707.293l5.414 5.414a1 1 0 01.293.707V19a2 2 0 01-2 2z"></path></svg></button>
                           <button id="newRehearsalBtn" class="px-4 py-2 font-semibold text-sm btn-secondary">새 리허설 시작</button>
                        </div>
                    </div>
                    
                    <div class="report-card p-4 sm:p-6 space-y-4">
                        <div class="text-center">
                            <p class="text-sm text-text-tertiary">최종 평가 등급</p>
                            <div class="flex items-center justify-center space-x-2 text-xl font-bold ${gradeInfo[finalGrade]?.color || 'bg-gray-500'} py-1 px-3 rounded-full inline-flex my-2">
                                ${gradeInfo[finalGrade]?.icon || ''}
                                <span>${gradeInfo[finalGrade]?.text || finalGrade}</span>
                            </div>
                        </div>
                        <p class="text-sm text-text-secondary text-center italic border-t border-border-color pt-4">"${overallReview}"</p>
                    </div>
                    
                    ${scriptAnalysisHTML}

                    <div class="report-card p-4 sm:p-6">
                         <div class="flex justify-between items-center mb-4">
                             <h3 class="text-lg font-semibold text-accent-primary">5대 핵심 역량 대시보드</h3>
                             <button id="toggleChartBtn" class="text-xs btn-secondary px-2 py-1">설명 보기</button>
                         </div>
                         <div id="chartContainer" class="w-full max-w-md mx-auto">
                             <canvas id="rubricChart"></canvas>
                         </div>
                         <div id="rubricListContainer" class="hidden space-y-3 mt-4">
                             ${(rubricScores || []).map(item => `
                                 <div class="border-t border-border-color pt-3">
                                     <div class="flex justify-between items-baseline">
                                         <p class="font-semibold text-text-primary">${item.axis}</p>
                                         <p class="text-sm font-bold text-accent-primary">${item.score}/5</p>
                                     </div>
                                     <p class="text-xs text-text-tertiary">${item.summary}</p>
                                 </div>
                             `).join('')}
                         </div>
                    </div>
                    
                    ${createSectionHTML('기술 (Voice/Body/Camera)', '🎤', detailedBreakdown.technicalControl)}
                    ${createSectionHTML('감정의 진정성·표현력', '🎭', detailedBreakdown.emotionalAuthenticity)}
                    ${detailedBreakdown.interpretationAndCharacterization ? createSectionHTML('해석·캐릭터 구현', '🤫', detailedBreakdown.interpretationAndCharacterization) : ''}
                    ${createSectionHTML('상호작용·듣기', '👂', detailedBreakdown.interactionAndListening)}

                    <div class="report-card p-4 sm:p-6">
                        <h3 class="text-lg font-semibold text-accent-primary mb-4">주요 알림 구간 (On-Set Alerts)</h3>
                        <div class="space-y-3">
                        ${(onSetAlerts || []).map(item => `
                            <div class="flex items-start p-3 rounded-lg bg-bg-primary">
                                <div class="w-5 h-5 mr-3 flex-shrink-0 text-yellow-400 mt-1">⚠️</div>
                                <p class="text-sm text-text-secondary"><strong class="font-semibold">${item.alertType}:</strong> ${item.directorChecklist}</p>
                            </div>
                        `).join('')}
                        </div>
                    </div>
                    
                    <div class="report-card p-4 sm:p-6">
                        <h3 class="text-lg font-semibold text-green-500 mb-4">종합 연기 평가</h3>
                        <p class="text-sm text-text-secondary leading-relaxed whitespace-pre-line">${grandCritique}</p>
                    </div>
                `;
                
                const ctx = document.getElementById('rubricChart').getContext('2d');
                new Chart(ctx, {
                    type: 'radar',
                    data: chartData,
                    options: {
                        scales: {
                            r: {
                                beginAtZero: true, max: 5, stepSize: 1,
                                angleLines: { color: 'rgba(47, 61, 55, 0.2)' },
                                grid: { color: 'rgba(47, 61, 55, 0.2)' },
                                pointLabels: { color: 'var(--text-primary)', font: { size: 12 } },
                                ticks: { backdropColor: 'transparent', color: 'var(--text-secondary)' }
                            }
                        },
                        plugins: { legend: { display: false } }
                    }
                });


                document.getElementById('newRehearsalBtn').addEventListener('click', resetForNewRehearsal);
                document.getElementById('toggleChartBtn').addEventListener('click', (e) => {
                    document.getElementById('chartContainer').classList.toggle('hidden');
                    document.getElementById('rubricListContainer').classList.toggle('hidden');
                    e.target.textContent = e.target.textContent === '설명 보기' ? '차트 보기' : '설명 보기';
                });
                
                document.getElementById('saveJpgBtn').addEventListener('click', () => {
                    showNotification('리포트를 이미지로 저장 중입니다...', false);
                    html2canvas(document.getElementById('feedbackReport'), { backgroundColor: '#F0F5F2', useCORS: true, scale: 2 }).then(canvas => {
                        const link = document.createElement('a');
                        link.download = 'AcTi_Report.jpg';
                        link.href = canvas.toDataURL('image/jpeg');
                        link.click();
                    });
                });
                document.getElementById('savePdfBtn').addEventListener('click', () => {
                    showNotification('리포트를 PDF로 저장 중입니다...', false);
                    const { jsPDF } = window.jspdf;
                    html2canvas(document.getElementById('feedbackReport'), { backgroundColor: '#F0F5F2', useCORS: true, scale: 2 }).then(canvas => {
                        const imgData = canvas.toDataURL('image/png');
                        const pdf = new jsPDF({ orientation: 'p', unit: 'px', format: [canvas.width, canvas.height] });
                        pdf.addImage(imgData, 'PNG', 0, 0, canvas.width, canvas.height);
                        pdf.save('AcTi_Report.pdf');
                    });
                });
            }
            
            // 데이터 분석 함수 개선
            function analyzeData(data, isVoice) {
                if (!data || data.length < 10) { // 데이터 포인트가 너무 적으면 분석 불가
                    return { mean: 0, stdDev: 0, peak: 0, silenceRatio: 100, isDataPresent: false };
                }

                const mean = data.reduce((a, b) => a + b, 0) / data.length;
                const stdDev = Math.sqrt(data.map(x => Math.pow(x - mean, 2)).reduce((a, b) => a + b, 0) / data.length);
                const peak = Math.max(...data);
                
                // 음성 데이터의 '침묵' 기준점
                const silenceThreshold = isVoice ? 2.0 : 0.1;
                const silentFrames = data.filter(d => d < silenceThreshold).length;
                const silenceRatio = (silentFrames / data.length) * 100;

                return {
                    mean: mean,
                    stdDev: stdDev,
                    peak: peak,
                    silenceRatio: silenceRatio,
                    isDataPresent: true
                };
            }
            
            async function handleFileUpload(file) {
                if (file.type.startsWith('image/')) {
                    await extractTextFromImage(file);
                    return;
                }

                let text = '';
                if (file.type === 'text/plain') {
                    text = await file.text();
                    await processExtractedText(text);
                } else if (file.name.endsWith('.srt')) {
                    const srtContent = await file.text();
                    text = srtContent.replace(/(^\d+$)|(\d{2}:\d{2}:\d{2},\d{3}\s+-->\s+\d{2}:\d{2}:\d{2},\d{3}$)|(<[^>]*>)/gm, '').replace(/^\s*[\r\n]/gm, '').trim();
                    await processExtractedText(text);
                } else if (file.type === 'application/pdf') {
                    const reader = new FileReader();
                    reader.onload = async (e) => {
                        scriptInput.value = 'PDF 파일에서 텍스트를 추출하는 중...';
                        reformatSpinner.classList.remove('hidden');
                        const typedarray = new Uint8Array(e.target.result);
                        const pdf = await pdfjsLib.getDocument(typedarray).promise;
                        let pdfText = '';
                        for (let i = 1; i <= pdf.numPages; i++) {
                            const page = await pdf.getPage(i);
                            const content = await page.getTextContent();
                            pdfText += content.items.map(item => item.str).join(' ');
                        }
                        await processExtractedText(pdfText);
                    };
                    reader.readAsArrayBuffer(file);
                } else { 
                    showNotification('지원하지 않는 파일 형식입니다. (PDF, TXT, SRT, 이미지)', true); 
                }
            }
            
            async function extractTextFromImage(file) {
                scriptInput.value = '이미지에서 텍스트를 추출하는 중...';
                reformatSpinner.classList.remove('hidden');
                try {
                    const base64Data = await new Promise((resolve, reject) => {
                        const reader = new FileReader();
                        reader.onloadend = () => resolve(reader.result.split(',')[1]);
                        reader.onerror = reject;
                        reader.readAsDataURL(file);
                    });

                    const payload = {
                        contents: [{
                            parts: [
                                { text: "Extract text from this image. Respond only with the extracted text in Korean." },
                                {
                                    inlineData: {
                                        mimeType: file.type,
                                        data: base64Data
                                    }
                                }
                            ]
                        }]
                    };
                    
                    const result = await callGeminiAPI(payload);
                    if (result.candidates && result.candidates.length > 0) {
                        const extractedText = result.candidates[0].content.parts[0].text;
                        await processExtractedText(extractedText);
                    } else {
                        throw new Error("No text found in image.");
                    }

                } catch (error) {
                    console.error("OCR Error:", error);
                    showNotification('이미지에서 텍스트를 추출하는 데 실패했습니다.', true);
                    scriptInput.value = ''; // Clear the textarea on failure
                    reformatSpinner.classList.add('hidden');
                }
            }


            async function processExtractedText(text) {
                scriptInput.value = 'AcTi가 대본을 재배열하는 중...';
                reformatSpinner.classList.remove('hidden');
                try {
                    const API_URL = `https://generativelanguage.googleapis.com/v1beta/models/gemini-2.5-flash-preview-05-20:generateContent?key=${userApiKey}`;
                    const payload = { 
                        systemInstruction: { parts: [{ text: "당신은 전문 스크립트 에디터입니다. 당신의 임무는 주어진 텍스트를 배우가 보기 편한 '촬영용 대본' 형식으로 재배열하는 것입니다. 다음 규칙을 반드시 준수하십시오:\n1. 캐릭터 이름이 있다면 줄을 바꿔 대문자로 표기합니다.\n2. 각 캐릭터의 대사와 지문은 의미 단위에 맞춰 자연스럽게 줄바꿈을 적용하여 가독성을 극대화합니다. 절대로 긴 문장을 한 줄로 붙여서는 안 됩니다.\n3. **절대로** 서론, 설명, 구분선(---) 등 대본 이외의 텍스트를 추가하지 마십시오.\n4. **절대로** 원본 텍스트에 없는 캐릭터 이름이나 내용을 창작하지 마십시오.\n오직 주어진 내용만을 재구성하여, 최종 결과물은 줄바꿈이 적용된 깔끔한 대본이어야 합니다." }] }, 
                        contents: [{ parts: [{ text: `다음 텍스트를 재배열해주세요:\n\n---\n${text}\n---` }] }] 
                    };
                    const response = await fetch(API_URL, { method: 'POST', headers: { 'Content-Type': 'application/json' }, body: JSON.stringify(payload) });
                    if (!response.ok) throw new Error('API Reformat Failed');
                    const data = await response.json();
                    scriptInput.value = data.candidates[0].content.parts[0].text;
                } catch(error) {
                    showNotification('대본 재배열에 실패했습니다.', true);
                    scriptInput.value = text;
                } finally {
                    reformatSpinner.classList.add('hidden');
                    startRehearsalBtn.disabled = scriptInput.value.trim().length === 0;
                }
            }
            
            function updateTeleprompterText() {
                teleprompterText.style.transform = `translateY(0px)`;
                // Set padding dynamically based on video container height
                const videoHeight = videoContainer.clientHeight;
                teleprompterText.style.paddingTop = `${videoHeight / 2}px`;
                teleprompterText.style.paddingBottom = `${videoHeight / 2}px`;
                teleprompterText.textContent = scriptInput.value;
            }

            function startTeleprompterScroll(isPreview) {
                stopTeleprompterScroll(); // Stop any previous scroll
                let scrollPosition = 0;
                let scrollSpeed = scrollSpeedSlider.value;
                
                const textHeight = teleprompterText.scrollHeight;
                const containerHeight = teleprompterOverlay.clientHeight;
                if (textHeight <= containerHeight) return;
                
                // Speed mapping: 1 (slowest) to 20 (fastest)
                const scrollInterval = 210 - (scrollSpeed * 10);

                teleprompterIntervalId = setInterval(() => {
                    scrollPosition += 1;
                    teleprompterText.style.transform = `translateY(-${scrollPosition}px)`;
                    if (scrollPosition > textHeight - containerHeight / 2) {
                        stopTeleprompterScroll();
                        if (isPreview) {
                           isTeleprompterPreviewing = false;
                           previewScrollBtn.textContent = '미리보기';
                        }
                    }
                }, scrollInterval);
            }
            
            function stopTeleprompterScroll() {
                if(teleprompterIntervalId) clearInterval(teleprompterIntervalId);
                teleprompterText.style.transition = 'none';
                teleprompterText.style.transform = `translateY(0px)`;
                void teleprompterText.offsetHeight; // Force reflow
                teleprompterText.style.transition = 'transform 1s linear';
            }

            function toggleTeleprompterPreview() {
                if (isTeleprompterPreviewing) {
                    stopTeleprompterScroll();
                    previewScrollBtn.textContent = '미리보기';
                    isTeleprompterPreviewing = false;
                } else {
                    if (!scriptInput.value.trim()) {
                        showNotification('미리보기를 위해 대본을 입력해주세요.', true);
                        return;
                    }
                    startTeleprompterScroll(true); // true means it's a preview
                    previewScrollBtn.textContent = '중지';
                    isTeleprompterPreviewing = true;
                }
            }

            // Event Listeners
            startLiveBtn.addEventListener('click', () => setupCamera());
            uploadVideoBtn.addEventListener('click', () => videoFileInput.click());
            videoFileInput.addEventListener('change', handleVideoUpload);
            startRehearsalBtn.addEventListener('click', startRehearsal);
            stopRehearsalBtn.addEventListener('click', stopAndAnalyze);
            switchCameraBtn.addEventListener('click', switchCamera);
            
            uploadBtn.addEventListener('click', () => fileInput.click());
            fileInput.addEventListener('change', (e) => {
                if (e.target.files[0]) handleFileUpload(e.target.files[0]);
                e.target.value = '';
            });
            helpBtn.addEventListener('click', () => helpModal.classList.remove('hidden'));
            closeHelpModalBtn.addEventListener('click', () => helpModal.classList.add('hidden'));
            helpModal.addEventListener('click', (e) => { if (e.target === helpModal) helpModal.classList.add('hidden'); });

            scrollSpeedSlider.addEventListener('input', () => {
                if (isTeleprompterPreviewing) {
                    startTeleprompterScroll(true);
                }
            });

            previewScrollBtn.addEventListener('click', toggleTeleprompterPreview);
            
            teleprompterToggle.addEventListener('change', () => {
                const isEnabled = teleprompterToggle.checked;
                teleprompterOverlay.classList.toggle('opacity-0', !isEnabled);
                teleprompterOverlay.classList.toggle('pointer-events-none', !isEnabled);
                teleprompterSettings.classList.toggle('hidden', !isEnabled);
                if (isEnabled) {
                    updateTeleprompterText()
                } else {
                    if (isTeleprompterPreviewing) {
                       toggleTeleprompterPreview();
                    }
                }
            });

            scriptInput.addEventListener('input', updateTeleprompterText);

            increaseFontSizeBtn.addEventListener('click', () => {
                currentFontSize = Math.min(60, currentFontSize + 2);
                teleprompterText.style.fontSize = `${currentFontSize}px`;
            });
            decreaseFontSizeBtn.addEventListener('click', () => {
                currentFontSize = Math.max(12, currentFontSize - 2);
                teleprompterText.style.fontSize = `${currentFontSize}px`;
            });

            scriptInput.addEventListener('input', () => {
                startRehearsalBtn.disabled = scriptInput.value.trim().length === 0;
                updateTeleprompterText();
            });

            initializeApp();
        });
    </script>
</body>
</html>


