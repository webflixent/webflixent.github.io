<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>AcTi 대본분석 - A급 연기 코칭</title>

    <!-- Web App & Home Screen Icon Settings -->
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
    <meta name="apple-mobile-web-app-title" content="AcTi 분석">
    <link rel="apple-touch-icon" href="actiscript.png">
    <link rel="icon" href="actiscript.png" type="image/png">
    <link rel="manifest" href="data:application/manifest+json;base64,eyJuYW1lIjoiQWNUaSBTY3JpcHQgQW5hbHlzaXMiLCJzaG9ydF9uYW1lIjoiQWNUaSIsInN0YXJ0X3VybCI6Ii4iLCJkaXNwbGF5Ijoic3RhbmRhbG9uZSIsImJhY2tncm91bmRfY29sb3IiOiIjMTIxMjEyIiwidGhlbWVfY29sb3IiOiIjMTIxMjEyIiwiaWNvbnMiOlt7InNyYyI6ImFjdGlzY3JpcHQucG5nIiwic2l6ZXMiOiIxOTJ4MTkyIiwidHlwZSI6ImltYWdlL3BuZyJ9LHsic3JjIjoiYWN0aXNjcmlwdC5wbmciLCJzaXplcyI6IjUxMng1MTIiLCJ0eXBlIjoiaW1hZ2UvcG5nIn1dfQ==">

    <link rel="stylesheet" as="style" crossorigin href="https://cdn.jsdelivr.net/gh/orioncactus/pretendard@v1.3.9/dist/web/static/pretendard.min.css" />
    <script src="https://cdnjs.cloudflare.com/ajax/libs/pdf.js/2.11.338/pdf.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/html2canvas/1.4.1/html2canvas.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/jspdf/2.5.1/jspdf.umd.min.js"></script>
    <style>
        /* 1. Global Reset & Design System (Professional Theme v5) */
        :root {
            --bg-color: #121212;
            --card-bg-color: #1E1E1E;
            --input-bg-color: #2A2A2A;
            --primary-yellow: #FFD60A;
            --primary-red: #FF3B30;
            --text-color: #FFFFFF;
            --subtext-color: #A0A0A0;
            --border-color: #383838;
            --font-family: 'Pretendard', -apple-system, BlinkMacSystemFont, system-ui, Roboto, sans-serif;
        }

        * { margin: 0; padding: 0; box-sizing: border-box; }

        body {
            font-family: var(--font-family);
            background-color: var(--bg-color);
            color: var(--text-color);
            line-height: 1.6;
        }

        .app-container { max-width: 600px; margin: 0 auto; min-height: 100vh; display: flex; flex-direction: column; }

        .screen-wrapper { flex-grow: 1; display: flex; flex-direction: column; }
        .screen { display: none; flex-direction: column; flex-grow: 1; }
        .screen.active { display: flex; }

        .btn {
            padding: 15px 20px; border: none; border-radius: 12px; font-size: 16px;
            font-weight: 700; cursor: pointer; transition: transform 0.2s, background-color 0.2s, box-shadow 0.2s;
            display: flex; align-items: center; justify-content: center; gap: 8px; width: 100%;
        }
        .btn:hover { transform: translateY(-2px); }

        .btn-primary { 
            background: linear-gradient(145deg, #ff4d43, #e6342a);
            color: var(--text-color); 
            box-shadow: 0 4px 15px rgba(255, 59, 48, 0.2);
        }
        .btn-primary:hover { box-shadow: 0 6px 20px rgba(255, 59, 48, 0.3); }
        .btn-primary:disabled { background: #444; color: #888; cursor: not-allowed; transform: none; box-shadow: none; }
        
        .btn-secondary {
            padding: 8px 16px;
            font-size: 13px;
            font-weight: 600;
            background-color: var(--input-bg-color);
            color: var(--subtext-color);
            border: 1px solid var(--border-color);
            border-radius: 8px;
            cursor: pointer;
            transition: all 0.2s;
        }
        .btn-secondary:hover {
            background-color: #3a3a3a;
            border-color: #555;
            color: var(--text-color);
        }

        .btn-back {
            background: none; border: none; color: var(--text-color);
            cursor: pointer; padding: 0; width: 44px; height: 44px; display: flex;
            align-items: center; justify-content: center; flex-shrink: 0;
        }
        
        .header-main { padding: 20px; }
        .app-container.loading-active .header-main { display: none; }
        .header-card {
            background-color: var(--card-bg-color); border: 1px solid var(--border-color);
            border-radius: 16px; padding: 20px; display: flex; align-items: center; gap: 15px;
            justify-content: center;
        }
        .header-main .logo-icon {
            width: 48px; height: 48px; background-color: transparent;
            border-radius: 12px;
            display: flex; align-items: center;
            justify-content: center; flex-shrink: 0;
        }
        .header-main .logo-icon svg { width: 24px; height: 24px; }
        .header-text-container { text-align: center; }
        .header-title { font-size: 20px; font-weight: 800; color: var(--text-color); }
        .header-subtitle { font-size: 14px; color: var(--subtext-color); }
        
        .header-sub { 
            padding: 15px; display: flex; align-items: center; justify-content: space-between; 
            border-bottom: 1px solid var(--border-color);
        }
        .header-sub h2 { font-size: 20px; font-weight: 700; text-align: center; flex-grow: 1; margin: 0 10px; }
        .header-actions { display: flex; gap: 10px; flex-shrink: 0; }

        .content { padding: 0 20px 20px; flex-grow: 1; overflow-y: auto; display: flex; flex-direction: column; gap: 20px; }
        
        .main-card {
            background-color: var(--card-bg-color); border-radius: 16px;
            border: 1px solid var(--border-color); padding: 20px;
            box-shadow: 0 8px 30px rgba(0,0,0,0.3);
        }
        
        .input-actions { display: flex; gap: 10px; margin-bottom: 20px; }
        .icon-btn {
            width: 48px; height: 48px; background-color: var(--input-bg-color);
            border: 1px solid var(--border-color); border-radius: 12px;
            display: flex; align-items: center; justify-content: center;
            cursor: pointer; transition: background-color 0.2s, border-color 0.2s, transform 0.2s;
        }
        .icon-btn:hover { background-color: #3a3a3a; border-color: #555; transform: translateY(-2px); }
        .icon-btn svg { width: 24px; height: 24px; stroke: var(--subtext-color); }

        .icon-btn.primary {
            background: linear-gradient(145deg, #ff4d43, #e6342a);
            border-color: transparent;
        }
        .icon-btn.primary svg { stroke: var(--text-color); }
        .icon-btn.primary:hover { background: linear-gradient(145deg, #ff5c52, #fa4238); }
        
        .hidden-input { display: none; }

        #script-input {
            width: 100%; height: 25vh; background-color: var(--input-bg-color); color: var(--text-color);
            border: 1px solid var(--border-color); border-radius: 12px; padding: 15px;
            font-size: 15px; resize: none; font-family: var(--font-family);
            transition: border-color 0.2s, box-shadow 0.2s;
        }
        #script-input:focus { outline: none; border-color: var(--primary-red); box-shadow: 0 0 0 3px rgba(255, 59, 48, 0.3); }
        
        .analysis-options { border-top: 1px solid var(--border-color); margin-top: 20px; padding-top: 20px; }
        .option-item { display: flex; justify-content: space-between; align-items: center; margin-bottom: 15px; }
        .option-item:last-child { margin-bottom: 0; }
        .option-label { font-size: 15px; font-weight: 500; color: var(--subtext-color); }

        .toggle-switch { display: flex; border-radius: 10px; overflow: hidden; background-color: var(--input-bg-color); width: 140px; }
        .toggle-switch input { display: none; }
        .toggle-switch label { flex: 1; text-align: center; padding: 8px 0; cursor: pointer; transition: background-color 0.3s, color 0.3s; margin: 0; font-size: 14px; font-weight: 500; }
        .toggle-switch input:checked + label { background-color: var(--primary-red); color: var(--text-color); font-weight: 700; }

        #character-select { width: 160px; padding: 8px 12px; background-color: var(--input-bg-color); color: var(--text-color); border: 1px solid var(--border-color); border-radius: 10px; font-size: 14px; -webkit-appearance: none; appearance: none; background-image: url("data:image/svg+xml,%3Csvg width='24' height='24' viewBox='0 0 24 24' fill='none' xmlns='http://www.w3.org/2000/svg'%3E%3Cpath d='M7 10L12 15L17 10' stroke='%23A0A0A0' stroke-width='2' stroke-linecap='round' stroke-linejoin='round'/%3E%3C/svg%3E"); background-repeat: no-repeat; background-position: right 8px center; padding-right: 30px; }

        #loading-screen { justify-content: center; align-items: center; text-align: center; padding: 20px; }
        .waveform { display: flex; justify-content: center; align-items: center; height: 60px; margin-bottom: 30px; }
        .waveform .bar { width: 8px; height: 10px; background-color: #FFF; margin: 0 4px; border-radius: 4px; animation: wave 1.2s infinite ease-in-out; }
        .waveform .bar:nth-child(2) { animation-delay: 0.1s; background-color: var(--primary-yellow); }
        .waveform .bar:nth-child(3) { animation-delay: 0.2s; }
        .waveform .bar:nth-child(4) { animation-delay: 0.3s; background-color: var(--primary-yellow);}
        .waveform .bar:nth-child(5) { animation-delay: 0.4s; }

        @keyframes wave { 0%, 100% { transform: scaleY(0.5); opacity: 0.6; } 50% { transform: scaleY(3.5); opacity: 1; } }
        .loading-text { font-size: 20px; font-weight: 600; margin-bottom: 20px; }
        .loading-tip { font-size: 15px; color: var(--subtext-color); }

        .report-tabs { display: flex; border-bottom: 1px solid var(--border-color); margin: 0 20px; }
        .tab-link { flex: 1; padding: 15px 0; background: none; border: none; color: var(--subtext-color); font-size: 15px; cursor: pointer; transition: color 0.3s, border-bottom-color 0.3s; border-bottom: 3px solid transparent; font-weight: 600; }
        .tab-link.active { color: var(--primary-yellow); border-bottom-color: var(--primary-yellow); }
        
        .tab-content { display: none; padding-top: 30px; }
        .tab-content.active { display: block; }
        
        .report-section-title { font-size: 20px; font-weight: 700; color: var(--text-color); margin-bottom: 20px; display: flex; align-items: center; gap: 10px; }
        .report-section-title svg { width: 24px; height: 24px; fill: var(--subtext-color); }

        .analysis-card { background-color: var(--card-bg-color); padding: 20px; border-radius: 12px; margin-bottom: 20px; border: 1px solid var(--border-color); }
        .analysis-card h4 { font-size: 16px; color: var(--primary-yellow); margin-bottom: 12px; font-weight: 700; }
        .analysis-card p { font-size: 15px; margin-bottom: 15px; line-height: 1.7; color: #E0E0E0; }
        .analysis-card strong { color: var(--subtext-color); font-weight: 600; }

        .mood-keywords .keyword { display: inline-block; background-color: var(--input-bg-color); padding: 6px 14px; border-radius: 50px; margin-right: 8px; margin-bottom: 8px; font-size: 14px; font-weight: 500; }
        .palette-container { display: flex; justify-content: space-between; align-items: center; margin-top: 15px; }
        .color-palette { display: flex; }
        .color-chip { width: 40px; height: 40px; border-radius: 50%; margin-right: 10px; border: 2px solid var(--bg-color); box-shadow: 0 2px 5px rgba(0,0,0,0.2); }
        .highlight-text { background-color: rgba(255, 214, 10, 0.1); padding: 20px; border-left: 4px solid var(--primary-yellow); font-weight: 500; border-radius: 0 8px 8px 0; }
        
        .emotion-graph-container { padding: 20px; background-color: #161616; border-radius: 8px; margin-top: 15px; border: 1px solid var(--border-color); }
        .emotion-graph { width: 100%; height: 150px; }
        .emotion-table { margin-top: 20px; width: 100%; border-collapse: collapse; }
        .emotion-table th, .emotion-table td { padding: 12px; text-align: left; border-bottom: 1px solid var(--border-color); font-size: 14px; }
        .emotion-table th { font-weight: 600; color: var(--subtext-color); }
        .emotion-table .point-number { text-align: center; font-weight: 700; color: var(--primary-yellow); }


        .line-coaching-item { border: 1px solid var(--border-color); border-radius: 12px; padding: 20px; margin-bottom: 20px; background: linear-gradient(145deg, #222, #1a1a1a); }
        .line-text { font-size: 17px; font-weight: 600; color: #fff; margin-bottom: 15px; padding-bottom: 15px; border-bottom: 1px dashed var(--border-color); font-style: italic; }
        .coaching-details p { font-size: 14px; margin-bottom: 10px; }
        .coaching-details strong { color: var(--subtext-color); display: inline-block; min-width: 80px; }

        .power-balance { margin-top: 20px; }
        .balance-bar-container { display: flex; align-items: center; margin-bottom: 15px; }
        .balance-label { font-size: 14px; width: 80px; color: var(--subtext-color); }
        .balance-bar { flex-grow: 1; height: 12px; background-color: var(--input-bg-color); border-radius: 6px; overflow: hidden; }
        .balance-fill { height: 100%; background: linear-gradient(90deg, #e6c300, #ffd60a); transition: width 0.8s cubic-bezier(0.25, 1, 0.5, 1); }
        
        .notification-toast {
            background-color: var(--primary-red); color: var(--text-color); padding: 12px 20px;
            border-radius: 10px; font-weight: 600; box-shadow: 0 4px 20px rgba(0,0,0,0.4);
            opacity: 0; transform: translateY(20px); transition: opacity 0.3s ease, transform 0.3s ease;
        }
        .notification-toast.show { opacity: 1; transform: translateY(0); }

        /* Modal Styles */
        .modal-overlay {
            position: fixed;
            top: 0; left: 0; width: 100%; height: 100%;
            background: rgba(0, 0, 0, 0.7);
            backdrop-filter: blur(5px);
            display: none;
            justify-content: center;
            align-items: center;
            z-index: 1001;
            opacity: 0;
            transition: opacity 0.3s ease;
        }
        .modal-overlay.show {
            display: flex;
            opacity: 1;
        }
        .modal-content {
            background-color: var(--card-bg-color);
            padding: 30px;
            border-radius: 16px;
            width: 90%;
            max-width: 500px;
            border: 1px solid var(--border-color);
            box-shadow: 0 10px 40px rgba(0,0,0,0.5);
            transform: scale(0.95);
            transition: transform 0.3s ease;
            max-height: 85vh;
            overflow-y: auto;
        }
        .modal-overlay.show .modal-content {
            transform: scale(1);
        }
        .modal-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            border-bottom: 1px solid var(--border-color);
            padding-bottom: 15px;
            margin-bottom: 20px;
        }
        .modal-header h4 {
            font-size: 18px;
            font-weight: 700;
            color: var(--primary-yellow);
        }
        .modal-close-btn {
            background: none; border: none; font-size: 24px; color: var(--subtext-color); cursor: pointer;
        }
        .color-meaning-item {
            display: flex;
            align-items: center;
            margin-bottom: 15px;
        }
        .color-meaning-item:last-child {
            margin-bottom: 0;
        }
        .color-meaning-item .color-chip {
            flex-shrink: 0;
            width: 30px; height: 30px;
        }
        .color-meaning-item p {
            font-size: 14px;
            color: var(--text-color);
            margin: 0 0 0 15px;
        }

        /* Relationship Table Styles */
        .relationship-card { margin-bottom: 15px; }
        .relationship-card h4 { font-size: 16px; margin-bottom: 15px; }
        .relationship-table { width: 100%; border-collapse: collapse; }
        .relationship-table td { padding: 10px; font-size: 14px; border-bottom: 1px solid var(--border-color); }
        .relationship-table tr:last-child td { border-bottom: none; }
        .relationship-table td:first-child { font-weight: 600; color: var(--subtext-color); width: 80px; }
        
        /* Director's View Styles */
        .director-card-header {
            display: flex;
            align-items: center;
            gap: 12px;
            margin-bottom: 15px;
        }
        .director-card-header svg {
            width: 20px;
            height: 20px;
            fill: var(--primary-yellow);
            flex-shrink: 0;
        }
        .director-card-header h4 {
            margin-bottom: 0;
        }

        /* Matching Modal Specific Styles */
        #matching-choice-modal .modal-content { max-width: 300px; }
        .matching-choice-btns { display: flex; flex-direction: column; gap: 15px; }
        
        #matching-result-modal .modal-content, #qa-modal .modal-content { max-width: 500px; }
        .matching-result-header { text-align: center; margin-bottom: 20px; }
        
        .progress-circle-container {
            position: relative;
            width: 120px;
            height: 120px;
            margin: 0 auto 15px;
        }
        .progress-circle-bg {
            fill: none;
            stroke: var(--input-bg-color);
        }
        .progress-circle-bar {
            fill: none;
            stroke: var(--primary-yellow);
            stroke-linecap: round;
            transform-origin: 50% 50%;
            transform: rotate(-90deg);
            transition: stroke-dashoffset 1s ease-out;
        }
        .progress-circle-text {
            fill: var(--text-color);
            font-size: 24px;
            font-weight: 700;
            text-anchor: middle;
        }
        .matching-result-header p {
            font-size: 16px;
            font-weight: 600;
        }
        
        /* Q&A Modal Styles */
        #qa-input {
            width: 100%;
            height: 100px;
            margin-bottom: 15px;
            background-color: var(--input-bg-color);
            color: var(--text-color);
            border: 1px solid var(--border-color);
            border-radius: 8px;
            padding: 10px;
            font-size: 15px;
            resize: vertical;
        }
        #qa-submit-btn { width: 100%; }
        #qa-answer-area {
            margin-top: 20px;
            padding: 15px;
            background-color: #161616;
            border-radius: 8px;
            min-height: 50px;
        }
         #qa-answer-area p {
            font-size: 15px;
            line-height: 1.7;
         }

    </style>
</head>
<body>
    <div class="app-container">
        <header class="header-main">
            <div class="header-card">
                <div class="logo-icon">
                    <img src="actiscript.png" alt="AcTi 로고" style="width: 100%; height: 100%; border-radius: 12px;">
                </div>
                <div class="header-text-container">
                      <h1 class="header-title">AcTi 대본분석</h1>
                      <p class="header-subtitle">준비된 배우를 위한 A-Class 연기 코칭</p>
                </div>
            </div>
        </header>
        <main class="screen-wrapper">
            <section id="main-screen" class="screen active">
                <div class="content">
                    <div class="main-card">
                        <div class="input-actions">
                            <label for="file-input" class="icon-btn primary" title="문서 파일 첨부">
                                 <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M14 2H6a2 2 0 0 0-2 2v16a2 2 0 0 0 2 2h12a2 2 0 0 0 2-2V8z"></path><polyline points="14 2 14 8 20 8"></polyline></svg>
                            </label>
                            <label for="gallery-input" class="icon-btn primary" title="갤러리에서 사진 선택">
                                <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><rect x="3" y="3" width="18" height="18" rx="2" ry="2"></rect><circle cx="8.5" cy="8.5" r="1.5"></circle><polyline points="21 15 16 10 5 21"></polyline></svg>
                            </label>
                            <label for="camera-input" class="icon-btn primary" title="카메라로 직접 촬영">
                                <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M23 19a2 2 0 0 1-2 2H3a2 2 0 0 1-2-2V8a2 2 0 0 1 2-2h4l2-3h6l2 3h4a2 2 0 0 1 2 2z"></path><circle cx="12" cy="13" r="4"></circle></svg>
                            </label>
                            <button class="icon-btn primary" id="clear-btn" title="내용 지우기">
                                <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><polyline points="3 6 5 6 21 6"></polyline><path d="M19 6v14a2 2 0 0 1-2 2H7a2 2 0 0 1-2-2V6m3 0V4a2 2 0 0 1 2-2h4a2 2 0 0 1 2 2v2"></path><line x1="10" y1="11" x2="10" y2="17"></line><line x1="14" y1="11" x2="14" y2="17"></line></svg>
                            </button>
                             <input type="file" id="file-input" class="hidden-input" accept=".txt,.srt,.pdf">
                             <input type="file" id="gallery-input" class="hidden-input" accept="image/*">
                             <input type="file" id="camera-input" class="hidden-input" accept="image/*" capture="environment">
                        </div>
                        <textarea id="script-input" placeholder="이곳에 대본을 붙여넣거나, 아이콘을 눌러 파일을 첨부하세요."></textarea>
                        
                        <div class="analysis-options">
                            <div class="option-item">
                                <span class="option-label">대본 형식</span>
                                 <div class="toggle-switch">
                                     <input type="radio" id="type-monologue" name="script-type" value="monologue">
                                     <label for="type-monologue">독백</label>
                                     <input type="radio" id="type-scene" name="script-type" value="scene" checked>
                                     <label for="type-scene">장면</label>
                                 </div>
                            </div>
                            <div class="option-item">
                                 <span class="option-label">분석할 캐릭터</span>
                                <select id="character-select" disabled>
                                    <option value="">대본 입력 후 선택</option>
                                </select>
                            </div>
                        </div>
                    </div>
                     <button id="analyze-btn" class="btn btn-primary" disabled>AcTi 분석 시작하기</button>
                </div>
            </section>

            <section id="loading-screen" class="screen">
                <div class="waveform">
                    <div class="bar"></div><div class="bar"></div><div class="bar"></div><div class="bar"></div><div class="bar"></div>
                </div>
                <p class="loading-text">AcTi 연기 분석 엔진 가동 중...</p>
                <p class="loading-tip" id="loadingTip"></p>
            </section>

            <section id="report-screen" class="screen">
                <header class="header-sub">
                    <button id="back-to-main-report" class="btn-back" title="새 분석 시작">
                        <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><line x1="12" y1="5" x2="12" y2="19"></line><line x1="5" y1="12" x2="19" y2="12"></line></svg>
                    </button>
                    <h2 id="report-title">AcTi 분석 리포트</h2>
                    <div class="header-actions">
                         <button id="qa-btn" class="icon-btn" title="AI에게 질문하기">
                            <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 15a2 2 0 0 1-2 2H7l-4 4V5a2 2 0 0 1 2-2h14a2 2 0 0 1 2 2z"></path></svg>
                        </button>
                         <button id="matching-btn" class="icon-btn" title="캐릭터 매칭">
                            <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M12 2a5 5 0 0 0-5 5c0 1.66 1.34 3 3 3h4c1.66 0 3-1.34 3-3a5 5 0 0 0-5-5z"></path><path d="M20 21a8 8 0 0 0-16 0"></path></svg>
                        </button>
                        <button id="save-jpg-btn" class="icon-btn" title="JPG로 저장">
                            <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><rect x="3" y="3" width="18" height="18" rx="2" ry="2"></rect><circle cx="8.5" cy="8.5" r="1.5"></circle><polyline points="21 15 16 10 5 21"></polyline></svg>
                        </button>
                        <button id="save-pdf-btn" class="icon-btn" title="PDF로 저장">
                             <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M14 2H6a2 2 0 0 0-2 2v16a2 2 0 0 0 2 2h12a2 2 0 0 0 2-2V8z"></path><polyline points="14 2 14 8 20 8"></polyline><line x1="16" y1="13" x2="8" y2="13"></line><line x1="16" y1="17" x2="8" y2="17"></line><polyline points="10 9 9 9 8 9"></polyline></svg>
                        </button>
                    </div>
                </header>

                <div class="report-tabs">
                    <button class="tab-link active" data-tab="overview">전체 조망</button>
                    <button class="tab-link" data-tab="character">캐릭터</button>
                    <button class="tab-link" data-tab="lines">대사 코칭</button>
                    <button class="tab-link" data-tab="relation">관계 분석</button>
                    <button class="tab-link" data-tab="director">종합 분석</button>
                </div>

                <div class="content report-content" id="report-content-to-capture">
                    <div id="overview" class="tab-content active">
                        <h3 class="report-section-title">
                            <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="currentColor"><path d="M12 4.5C7 4.5 2.73 7.61 1 12c1.73 4.39 6 7.5 11 7.5s9.27-3.11 11-7.5c-1.73-4.39-6-7.5-11-7.5zM12 17c-2.76 0-5-2.24-5-5s2.24-5 5-5 5 2.24 5 5-2.24 5-5 5zm0-8c-1.66 0-3 1.34-3 3s1.34 3 3 3 3-1.34 3-3-1.34-3-3-3z"/></svg>
                            장면 전체 조망 & 인사이트
                        </h3>
                        <div class="analysis-card">
                            <h4>분위기 및 톤앤매너</h4>
                            <div class="mood-keywords" id="report-atmosphere-keywords"></div>
                            <div class="palette-container">
                                <div class="color-palette" id="report-color-palette"></div>
                                <button id="show-color-meaning-btn" class="btn-secondary">컬러 의미보기</button>
                            </div>
                        </div>
                        <div class="analysis-card">
                            <h4>장면의 목표와 기능</h4>
                            <p id="report-scene-function"></p>
                        </div>
                        <div class="analysis-card">
                            <h4>핵심 갈등 구조 요약</h4>
                            <p class="highlight-text" id="report-conflict-summary"></p>
                        </div>
                    </div>
                    <div id="character" class="tab-content">
                        <h3 class="report-section-title">
                             <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="currentColor"><path d="M12 12c2.21 0 4-1.79 4-4s-1.79-4-4-4-4 1.79-4 4 1.79 4 4 4zm0 2c-2.67 0-8 1.34-8 4v2h16v-2c0-2.66-5.33-4-8-4z"/></svg>
                             캐릭터 심층 프로파일링: <span id="report-character-name"></span>
                        </h3>
                        <div class="analysis-card">
                            <h4>목표와 장애물</h4>
                            <p><strong>궁극적 목표 (Objective):</strong></p>
                            <p id="report-objective"></p>
                            <p><strong>장애물 (Obstacle):</strong></p>
                            <p id="report-obstacle"></p>
                        </div>
                        <div class="analysis-card">
                            <h4>심리 분석</h4>
                            <p><strong>서브텍스트 (Subtext):</strong></p>
                            <p id="report-subtext"></p>
                            <p><strong>주요 행동 동사 (Action Verbs):</strong></p>
                            <p id="report-action-verbs"></p>
                        </div>
                        <div class="analysis-card">
                            <h4>감정의 여정 (Emotional Journey)</h4>
                            <p>그래프의 번호와 아래 표를 함께 확인하며 감정의 흐름을 파악하세요.</p>
                            <div class="emotion-graph-container">
                                <svg class="emotion-graph" id="reportEmotionGraph" viewBox="0 0 100 50" preserveAspectRatio="xMinYMid meet"></svg>
                            </div>
                            <div id="emotion-table-container"></div>
                        </div>
                    </div>
                    <div id="lines" class="tab-content">
                        <h3 class="report-section-title">
                            <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="currentColor"><path d="M20 2H4c-1.1 0-2 .9-2 2v18l4-4h14c1.1 0 2-.9 2-2V4c0-1.1-.9-2-2-2zm-2 12H6v-2h12v2zm0-3H6V9h12v2zm0-3H6V6h12v2z"/></svg>
                            핵심 대사 집중 코칭 (Killing Line)
                        </h3>
                        <div id="report-key-lines"></div>
                    </div>
                    <div id="relation" class="tab-content">
                        <h3 class="report-section-title">
                            <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="currentColor"><path d="M16 11c1.66 0 2.99-1.34 2.99-3S17.66 5 16 5c-1.66 0-3 1.34-3 3s1.34 3 3 3zm-8 0c1.66 0 2.99-1.34 2.99-3S9.66 5 8 5C6.34 5 5 6.34 5 8s1.34 3 3 3zm0 2c-2.33 0-7 1.17-7 3.5V19h14v-2.5c0-2.33-4.67-3.5-7-3.5zm8 0c-.29 0-.62.02-.97.05 1.16.84 1.97 1.97 1.97 3.45V19h6v-2.5c0-2.33-4.67-3.5-7-3.5z"/></svg>
                            인물 관계 및 역학 분석
                        </h3>
                        <div id="report-relationships-container">
                            <!-- Detailed relationships will be injected here -->
                        </div>
                        <div class="analysis-card">
                            <h4>힘의 균형 (Power Balance)</h4>
                            <p id="report-power-dynamics"></p>
                            <div class="power-balance">
                                <div class="balance-bar-container">
                                    <div class="balance-label">시작 시점</div>
                                    <div class="balance-bar"><div class="balance-fill" id="balance-start"></div></div>
                                </div>
                                <div class="balance-bar-container">
                                    <div class="balance-label">종료 시점</div>
                                    <div class="balance-bar"><div class="balance-fill" id="balance-end"></div></div>
                                </div>
                            </div>
                        </div>
                    </div>
                    <div id="director" class="tab-content">
                        <h3 class="report-section-title">
                             <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="currentColor"><path d="M18 4l2 4h-3l-2-4h-2l2 4h-3l-2-4H8l2 4H7L5 4H4c-1.1 0-1.99.9-1.99 2L2 18c0 1.1.9 2 2 2h16c1.1 0 2-.9 2-2V4h-4z"/></svg>
                            감독 & 작가 관점 분석
                        </h3>
                        <div class="analysis-card">
                           <div class="director-card-header">
                                <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M19 3H5c-1.1 0-2 .9-2 2v14c0 1.1.9 2 2 2h14c1.1 0 2-.9 2-2V5c0-1.1-.9-2-2-2zm-5 14H7v-2h7v2zm3-4H7v-2h10v2zm0-4H7V7h10v2z"/></svg>
                                <h4>작가의 의도</h4>
                           </div>
                           <p id="director-writer-intent"></p>
                        </div>
                        <div class="analysis-card">
                            <div class="director-card-header">
                                <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M12 2C6.48 2 2 6.48 2 12s4.48 10 10 10 10-4.48 10-10S17.52 2 12 2zm0 18c-4.41 0-8-3.59-8-8s3.59-8 8-8 8 3.59 8 8-3.59 8-8 8z"/></svg>
                                <h4>핵심 주제와 상징</h4>
                            </div>
                            <p id="director-core-theme"></p>
                        </div>
                         <div class="analysis-card">
                            <div class="director-card-header">
                                <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M3 13h2v-2H3v2zm0 4h2v-2H3v2zm2 4v-2H3c0 1.1.9 2 2 2zM3 9h2V7H3v2zm12 12h2v-2h-2v2zm4-18H9v2h10V3zm-4 8h2V9h-2v2zm0-4h2V5h-2v2zm-4 12h2v-2h-2v2zm-8-8h2V9H3v2zm0 4h2v-2H3v2z"/></svg>
                                <h4>장면의 구조와 리듬</h4>
                            </div>
                            <p id="director-scene-structure"></p>
                        </div>
                         <div class="analysis-card">
                            <div class="director-card-header">
                                <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M12 3c-4.97 0-9 4.03-9 9v7c0 1.1.9 2 2 2h4v-8H5v-1c0-3.87 3.13-7 7-7s7 3.13 7 7v1h-4v8h4c1.1 0 2-.9 2-2v-7c0-4.97-4.03-9-9-9z"/></svg>
                                <h4>연출적 제언</h4>
                            </div>
                            <p id="director-suggestions"></p>
                        </div>
                    </div>
                </div>
            </div>
        </section>
    </main>
    <div id="notification-container" style="position: fixed; bottom: 20px; left: 50%; transform: translateX(-50%); z-index: 1000; display: flex; flex-direction: column; align-items: center; gap: 10px;"></div>

    <!-- Color Meaning Modal -->
    <div id="color-meaning-modal" class="modal-overlay">
        <div class="modal-content">
            <div class="modal-header">
                <h4>장면 컬러톤 분석</h4>
                <button class="modal-close-btn">&times;</button>
            </div>
            <div id="modal-color-content"></div>
        </div>
    </div>

    <!-- Matching Choice Modal -->
    <div id="matching-choice-modal" class="modal-overlay">
        <div class="modal-content">
            <div class="modal-header">
                <h4>캐릭터 매칭</h4>
                <button class="modal-close-btn">&times;</button>
            </div>
            <div class="matching-choice-btns">
                <label for="matching-gallery-input" class="btn btn-secondary">갤러리에서 사진 선택</label>
                <label for="matching-camera-input" class="btn btn-secondary">카메라로 촬영 (셀카)</label>
                <input type="file" id="matching-gallery-input" class="hidden-input" accept="image/*">
                <input type="file" id="matching-camera-input" class="hidden-input" accept="image/*" capture="user">
            </div>
        </div>
    </div>
    
    <!-- Matching Result Modal -->
    <div id="matching-result-modal" class="modal-overlay">
        <div class="modal-content">
            <div class="modal-header">
                <h4>캐릭터 매칭 분석 결과</h4>
                <button class="modal-close-btn">&times;</button>
            </div>
            <div id="matching-result-content">
                <!-- Matching results will be injected here -->
            </div>
        </div>
    </div>

    <!-- Q&A Modal -->
    <div id="qa-modal" class="modal-overlay">
        <div class="modal-content">
            <div class="modal-header">
                <h4>AI에게 질문하기</h4>
                <button class="modal-close-btn">&times;</button>
            </div>
            <div id="qa-content">
                <textarea id="qa-input" placeholder="분석 결과나 대본에 대해 궁금한 점을 질문하세요..."></textarea>
                <button id="qa-submit-btn" class="btn btn-primary">질문하기</button>
                <div id="qa-answer-area">
                    <p>AI의 답변이 여기에 표시됩니다.</p>
                </div>
            </div>
        </div>
    </div>


<script>
    document.addEventListener('DOMContentLoaded', () => {
        const { jsPDF } = window.jspdf;
        const mainScreen = document.getElementById('main-screen');
        const loadingScreen = document.getElementById('loading-screen');
        const reportScreen = document.getElementById('report-screen');
        const analyzeBtn = document.getElementById('analyze-btn');
        const scriptInput = document.getElementById('script-input');
        const characterSelect = document.getElementById('character-select');
        const fileInput = document.getElementById('file-input');
        const galleryInput = document.getElementById('gallery-input');
        const cameraInput = document.getElementById('camera-input');
        const clearBtn = document.getElementById('clear-btn');
        const saveJpgBtn = document.getElementById('save-jpg-btn');
        const savePdfBtn = document.getElementById('save-pdf-btn');
        const appContainer = document.querySelector('.app-container');

        // Modals
        const colorModal = document.getElementById('color-meaning-modal');
        const matchingChoiceModal = document.getElementById('matching-choice-modal');
        const matchingResultModal = document.getElementById('matching-result-modal');
        const qaModal = document.getElementById('qa-modal');
        const showColorMeaningBtn = document.getElementById('show-color-meaning-btn');
        const modalColorContent = document.getElementById('modal-color-content');
        
        const matchingBtn = document.getElementById('matching-btn');
        const qaBtn = document.getElementById('qa-btn');
        const matchingGalleryInput = document.getElementById('matching-gallery-input');
        const matchingCameraInput = document.getElementById('matching-camera-input');
        
        let currentAnalysisReport = null;
        let currentMatchingReport = null;
        let lastMatchedImage = null;
        let currentColorScheme = [];

        // IMPORTANT: Gemini API 키가 입력되었습니다.
        const GEMINI_API_KEY = "AIzaSyBbEsfDqt5ojPAJoo70Nozro4LacKk__4k";

        if (window.pdfjsLib) {
            pdfjsLib.GlobalWorkerOptions.workerSrc = 'https://cdnjs.cloudflare.com/ajax/libs/pdf.js/2.11.338/pdf.worker.min.js';
        }

        function showScreen(screenElement) {
            document.querySelectorAll('.screen').forEach(s => s.classList.remove('active'));
            screenElement.classList.add('active');
            
            if (screenElement.id === 'loading-screen') {
                appContainer.classList.add('loading-active');
            } else {
                appContainer.classList.remove('loading-active');
            }
            window.scrollTo(0, 0);
        }

        document.getElementById('back-to-main-report').addEventListener('click', () => {
            scriptInput.value = '';
            scriptInput.dispatchEvent(new Event('input', { bubbles: true }));
            resetCharacterSelect();
            currentAnalysisReport = null;
            currentMatchingReport = null;
            lastMatchedImage = null;
            showScreen(mainScreen);
        });
        
        document.querySelectorAll('.tab-link').forEach(button => {
            button.addEventListener('click', (e) => {
                const tabId = e.currentTarget.getAttribute('data-tab');
                document.querySelectorAll('.tab-link').forEach(btn => btn.classList.remove('active'));
                document.querySelectorAll('.tab-content').forEach(content => content.classList.remove('active'));
                e.currentTarget.classList.add('active');
                document.getElementById(tabId).classList.add('active');
            });
        });

        function showNotification(message, duration = 3000) {
            const container = document.getElementById('notification-container');
            const notif = document.createElement('div');
            notif.className = 'notification-toast';
            notif.textContent = message;
            container.appendChild(notif);
            setTimeout(() => { notif.classList.add('show'); }, 10);
            setTimeout(() => {
                notif.classList.remove('show');
                notif.addEventListener('transitionend', () => notif.remove());
            }, duration);
        }
        
        function debounce(func, delay) {
            let timeout;
            return function(...args) {
                clearTimeout(timeout);
                timeout = setTimeout(() => func.apply(this, args), delay);
            };
        }

        const debouncedCharacterExtraction = debounce(async (script) => {
            if (script.length > 30) {
                await extractCharactersWithAI(script);
            } else {
                resetCharacterSelect();
            }
        }, 1000);

        scriptInput.addEventListener('input', (e) => {
            const script = e.target.value.trim();
            analyzeBtn.disabled = script.length === 0;
            debouncedCharacterExtraction(script);
        });
        
        clearBtn.addEventListener('click', () => {
            scriptInput.value = '';
            scriptInput.dispatchEvent(new Event('input', { bubbles: true }));
            resetCharacterSelect();
            currentAnalysisReport = null;
            currentMatchingReport = null;
            lastMatchedImage = null;
        });


        async function callGeminiAPI(payload) {
             if (!GEMINI_API_KEY || GEMINI_API_KEY === "YOUR_API_KEY") {
                throw new Error("Gemini API Key is not configured.");
            }
            const apiUrl = `https://generativelanguage.googleapis.com/v1beta/models/gemini-1.5-flash:generateContent?key=${GEMINI_API_KEY}`;
            const response = await fetch(apiUrl, {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify(payload)
            });
            if (!response.ok) {
                const errorBody = await response.json();
                console.error("API Error Response:", errorBody);
                throw new Error(`API Error: ${response.status} ${response.statusText}`);
            }
            return await response.json();
        }

        async function extractCharactersWithAI(script) {
            characterSelect.innerHTML = `<option value="">AcTi로 캐릭터 추출 중...</option>`;
            characterSelect.disabled = true;

            const systemPrompt = `You are a highly intelligent script analysis AI. Your task is to meticulously extract ONLY the character names from a given script, regardless of its formatting. You must be extremely precise and understand the structure of a script.

**Rules for Character Name Extraction:**
1.  **Identify Speaking Characters:** A character name is the identifier for a block of dialogue. It typically appears on its own line, or is followed by a colon (e.g., "CHARACTER: Dialogue...")
2.  **Isolate the Name ONLY:** You must extract *only the name* and nothing else. Do not include any part of the dialogue, punctuation like colons, or surrounding words.
    * **Correct:** \`["수애", "도둑", "경수"]\`
    * **Incorrect:** \`["수애:", "도둑 집에", "경수(화내며)"]\`
3.  **Ignore Scene Directions and Parentheticals:** Do not extract text that is clearly a scene description, action, or emotional cue, which is often inside parentheses \`()\`.
4.  **Handle Common Script Formats:**
    * **Format A (Name on new line):**
        \`\`\`
        수애
        (놀라며) 누구세요?
        \`\`\`
        -> Extract "수애".
    * **Format B (Name with colon):**
        \`\`\`
        도둑: 가만히 있어.
        \`\`\`
        -> Extract "도둑".
5.  **Be Smart About What a Name Is:** Character names are proper nouns or roles (e.g., "수애", "경수", "도둑", "수애 아저씨"). A line of dialogue like "희재 왜 그랬어?" is NOT a character name. You must differentiate between a name cue and dialogue itself.
6.  **Final Output:** Return a clean JSON object with a single key "characters" containing an array of the *unique* character names found. If no characters are found, return an empty array.`;
            const userQuery = `Analyze the following script and return a JSON object of unique character names.\n\nScript:\n---\n${script}\n---`;
            
            const payload = {
                contents: [{ parts: [{ text: userQuery }] }],
                systemInstruction: { parts: [{ text: systemPrompt }] },
                generationConfig: {
                    responseMimeType: "application/json",
                }
            };

            try {
                const result = await callGeminiAPI(payload);
                 if (!result.candidates?.[0]?.content?.parts?.[0]?.text) {
                    throw new Error("AI로부터 유효한 응답을 받지 못했습니다.");
                }
                const jsonText = result.candidates[0].content.parts[0].text.trim();
                 if (!jsonText) {
                    throw new Error("AI로부터 빈 응답을 받았습니다.");
                }
                const data = JSON.parse(jsonText);
                if (data.characters && data.characters.length > 0) {
                    populateCharacterSelect(data.characters);
                } else {
                    resetCharacterSelect("추출된 캐릭터가 없습니다.");
                }
            } catch (error) {
                console.error("캐릭터 추출 AI 오류:", error);
                showNotification(`캐릭터 추출 오류: ${error.message}`, 4000);
                resetCharacterSelect("오류: 캐릭터 추출 실패");
            }
        }

        function populateCharacterSelect(characters) {
            const currentVal = characterSelect.value;
            characterSelect.innerHTML = '<option value="">분석할 캐릭터 선택</option>';
            characters.forEach(char => {
                const option = document.createElement('option');
                option.value = char; option.textContent = char;
                characterSelect.appendChild(option);
            });
            if(characters.includes(currentVal)) characterSelect.value = currentVal;
            characterSelect.disabled = false;
        }

        function resetCharacterSelect(message = "대본 입력 후 선택") {
            characterSelect.innerHTML = `<option value="">${message}</option>`;
            characterSelect.disabled = true;
        }

        fileInput.addEventListener('change', async (event) => {
            await handleFile(event.target.files[0], 'document');
            event.target.value = '';
        });

        galleryInput.addEventListener('change', async (event) => {
            await handleFile(event.target.files[0], 'image');
            event.target.value = '';
        });
        
        cameraInput.addEventListener('change', async (event) => {
            await handleFile(event.target.files[0], 'image');
            event.target.value = '';
        });
        
        async function handleFile(file, type) {
            if (!file) return;
            analyzeBtn.disabled = true;
            showNotification(`${file.name} 처리 중...`, 2000);
            
            try {
                let content = '';
                if (type === 'image') {
                    content = await extractTextFromImage(file);
                } else {
                     const extension = file.name.split('.').pop().toLowerCase();
                     if (extension === 'txt') content = await readFileAsText(file);
                     else if (extension === 'srt') content = parseSrtContent(await readFileAsText(file));
                     else if (extension === 'pdf') content = await readPdfContent(file);
                     else { showNotification('지원하지 않는 파일 형식입니다.', 3000); return; }
                }
                
                if (scriptInput.value.trim().length > 0) {
                    scriptInput.value += '\n\n' + content;
                    showNotification('대본 페이지가 추가되었습니다.', 2000);
                } else {
                    scriptInput.value = content;
                    showNotification('성공적으로 불러왔습니다.', 2000);
                }

                scriptInput.dispatchEvent(new Event('input', { bubbles: true }));
                
            } catch(error) {
                console.error('파일 처리 중 오류 발생:', error);
                showNotification(`파일 처리 오류: ${error.message}`, 3000);
            } finally {
                analyzeBtn.disabled = scriptInput.value.trim().length === 0;
            }
        }

        async function extractTextFromImage(file) {
            showNotification('이미지에서 텍스트 추출 중...', 4000);
            const base64Data = await readFileAsBase64(file);
           
            const payload = {
                contents: [{
                    parts: [
                        { text: "Extract all text from this image. It is an acting script, so you must preserve the original line breaks and formatting exactly as they appear." },
                        { inline_data: { mime_type: file.type, data: base64Data } }
                    ]
                }]
            };

            const result = await callGeminiAPI(payload);
            return result.candidates[0].content.parts[0].text;
        }

        const readFileAsBase64 = file => new Promise((resolve, reject) => {
            const reader = new FileReader();
            reader.onload = () => resolve(reader.result.split(',')[1]);
            reader.onerror = error => reject(error);
            reader.readAsDataURL(file);
        });

        const readFileAsText = file => new Promise((resolve, reject) => { const reader = new FileReader(); reader.onload = () => resolve(reader.result); reader.onerror = () => reject(reader.error); reader.readAsText(file, 'UTF-8'); });
        
        const parseSrtContent = srtText => srtText.split(/\r?\n/).filter(line => !/^\d*$/.test(line) && !line.includes('-->')).map(line => line.replace(/<[^>]*>/g, '')).join('\n');

        const readPdfContent = file => new Promise((resolve, reject) => {
            if (!window.pdfjsLib) return reject(new Error('PDF 라이브러리를 불러오지 못했습니다.'));
            const reader = new FileReader();
            reader.onload = async (e) => {
                try {
                    const pdf = await pdfjsLib.getDocument(new Uint8Array(e.target.result)).promise;
                    let fullText = '';
                    for (let i = 1; i <= pdf.numPages; i++) {
                        const page = await pdf.getPage(i);
                        const textContent = await page.getTextContent();
                        const items = textContent.items.sort((a, b) => Math.abs(a.transform[5] - b.transform[5]) < 5 ? a.transform[4] - b.transform[4] : b.transform[5] - a.transform[5]);
                        let lastY = -1; let lineText = '';
                        for(const item of items) {
                            if (lastY !== -1 && Math.abs(item.transform[5] - lastY) > 5) { fullText += lineText + '\n'; lineText = ''; }
                            lineText += item.str; lastY = item.transform[5];
                        };
                        fullText += lineText + '\n';
                    }
                    resolve(fullText.trim());
                } catch (error) { reject(error); }
            };
            reader.onerror = () => reject(reader.error);
            reader.readAsArrayBuffer(file);
        });

        analyzeBtn.addEventListener('click', () => {
            const script = scriptInput.value.trim();
            const scriptType = document.querySelector('input[name="script-type"]:checked').value;
            let selectedCharacter = characterSelect.value;
            if (scriptType === 'scene' && !selectedCharacter && characterSelect.options.length > 1) { showNotification("분석할 캐릭터를 선택해주세요."); return; }
            if (!selectedCharacter) selectedCharacter = "주인공";
            if (script) startAIAnalysis(script, scriptType, selectedCharacter);
        });

        let tipInterval;
        async function startAIAnalysis(script, type, character) {
            showScreen(loadingScreen);
            showLoadingTips();
            
            const systemPrompt = `You are 'AcTi', a world-class acting coach, screenwriter, and director AI. Your analysis must be detailed, insightful, and professional, providing a sincere and deep guide for an actor. Analyze the script deeply and provide your insights in the specified JSON format.

**Analysis Sections:**
-   **directorsView:** Provide a highly detailed, professional-grade analysis from a director's and writer's perspective, as if you were teaching a masterclass. Each section must be a thorough, multi-sentence paragraph.
    -   **writerIntent**: Go beyond a simple summary. Analyze the *dramaturgical function* of the scene. What is its fundamental purpose in the narrative? What specific emotional journey is the audience meant to experience? What truth about the characters or the human condition is the writer trying to illuminate through this specific moment?
    -   **coreTheme**: Identify the core themes (e.g., love, betrayal, regret, hope). Do not just list them. Explain *how* these themes are woven into the fabric of the scene through dialogue, subtext, actions, and symbolism. Discuss any recurring motifs or symbolic objects.
    -   **sceneStructure**: Analyze the *rhythm and structure* of the scene in detail. Break down the scene's beats: the beginning state (stasis), the inciting incident within the scene, the rising action (points of conflict), the climax (the point of no return), and the resolution (the new stasis). Describe the pacing (e.g., is it allegro, with rapid-fire dialogue, or adagio, with long pauses and heavy silence?).
    -   **directorialSuggestions**: Offer concrete, imaginative *directorial suggestions* that would inspire an actor. Suggest specific camera work (e.g., "A slow push-in on the character during this line to emphasize their isolation"), sound design ("The distant sound of a clock ticking should be the only thing heard during the pause"), or lighting choices ("Use a single key light from the side to create a stark, confessional mood"). Explain the artistic reasoning behind each suggestion.
-   **sceneOverview**:
    -   For 'sceneFunction', provide a detailed paragraph. Explain the scene's purpose in the overall story, what it reveals about the characters, and how it moves the plot forward.
    -   For 'conflictSummary', write a comprehensive paragraph describing the central conflict in detail.
    -   'colors' must be an array of 3 objects, each with a 'hex' code and a 'meaning' (in Korean).
-   **emotionalJourney**: Maps the character's emotional progression. For each point, 'intensity' **MUST BE AN INTEGER between 0 and 100** (e.g., 85, not 0.85). This represents the percentage strength of the emotion.
-   **relationshipDynamics**: Analyze the selected character's relationship with *every other character* they interact with. Provide an array of objects for 'detailedRelationships'.
-   **keyLines**: Be generous and select at least 5-7 lines for an average length script.
-   **General**: ALL text output MUST be in Korean. The 'title' should be based on the script content.`;
            const userQuery = `Analyze this script:\n---\n${script}\n---\nContext:\n- Type: ${type}\n- Character: ${character}\nProvide a complete analysis.`;
            const payload = {
                contents: [{ parts: [{ text: userQuery }] }], 
                systemInstruction: { parts: [{ text: systemPrompt }] },
                generationConfig: {
                    responseMimeType: "application/json",
                    responseSchema: {type: 'OBJECT', properties: {title: { type: 'STRING' }, character: { type: 'STRING' }, type: { type: 'STRING' }, sceneOverview: {type: 'OBJECT', properties: {atmosphereKeywords: { type: 'ARRAY', items: { type: 'STRING' } }, colors: { type: 'ARRAY', items: { type: 'OBJECT', properties: { hex: { type: 'STRING' }, meaning: { type: 'STRING' } } } }, sceneFunction: { type: 'STRING' }, conflictSummary: { type: 'STRING' }}}, characterProfile: {type: 'OBJECT', properties: {objective: { type: 'STRING' }, obstacle: { type: 'STRING' }, subtext: { type: 'STRING' }, actionVerbs: { type: 'ARRAY', items: { type: 'STRING' } }, emotionalJourney: {type: 'ARRAY', items: {type: 'OBJECT', properties: {time: { type: 'NUMBER' }, emotion: { type: 'STRING' }, intensity: { type: 'NUMBER', description: "An INTEGER value between 0 and 100 representing emotional strength." }, line: { type: 'STRING' }}}}}}, keyLines: {type: 'ARRAY', items: {type: 'OBJECT', properties: {line: { type: 'STRING' }, intention: { type: 'STRING' }, tempo: { type: 'STRING' }, pause: { type: 'STRING' }, tone: { type: 'STRING' }}}}, relationshipDynamics: {type: 'OBJECT', properties: {powerDynamicsSummary: { type: 'STRING' }, balanceStart: { type: 'NUMBER' }, balanceEnd: { type: 'NUMBER' }, detailedRelationships: {type: 'ARRAY', items: {type: 'OBJECT', properties: {otherCharacter: { type: 'STRING' }, relationship: { type: 'STRING' }, dynamics: { type: 'STRING' }}}}}}, directorsView: {type: 'OBJECT', properties: {writerIntent: { type: 'STRING' }, coreTheme: { type: 'STRING' }, sceneStructure: { type: 'STRING' }, directorialSuggestions: { type: 'STRING' }}}}}
                }
            };
            try {
                const result = await callGeminiAPI(payload);
                 if (!result.candidates?.[0]?.content?.parts?.[0]?.text) {
                    throw new Error("AI로부터 유효한 응답을 받지 못했습니다 (응답 구조 오류).");
                }
                const jsonText = result.candidates[0].content.parts[0].text.trim();
                if (jsonText === "") {
                    throw new Error("AI로부터 빈 응답을 받았습니다. 대본 내용이나 API 키를 확인해주세요.");
                }
                
                let analysisReport;
                try {
                    analysisReport = JSON.parse(jsonText);
                } catch (parseError) {
                    console.error("JSON Parsing Error:", parseError);
                    console.error("Received Text from API:", jsonText);
                    throw new Error("AI가 반환한 데이터 형식이 올바르지 않습니다.");
                }

                currentAnalysisReport = analysisReport; // Store the latest report
                displayReport(analysisReport);
                showScreen(reportScreen);
            } catch (error) {
                console.error("AcTi 분석 중 오류 발생:", error);
                showNotification(`AcTi 분석 오류: ${error.message}`, 5000);
                showScreen(mainScreen);
            } finally { clearInterval(tipInterval); }
        }

        function showLoadingTips() {
            const tips = ["인물의 목표는 무엇일까요?", "상대방의 말을 경청하는 것이 좋은 연기의 시작입니다.", "호흡을 조절하는 것만으로도 감정의 깊이가 달라집니다.", "대사 이면의 '서브텍스트'를 찾아보세요.", "행동 동사(Action Verb)를 생각하며 대사를 해보세요."];
            let index = 0; const tipElement = document.getElementById('loadingTip');
            tipElement.innerHTML = `💡 <span>"${tips[index]}"</span>`;
            tipInterval = setInterval(() => {
                index = (index + 1) % tips.length;
                tipElement.innerHTML = `💡 <span>"${tips[index]}"</span>`;
            }, 2500);
        }
        
        async function captureReport(format = 'jpeg') {
            const fileExtension = format === 'jpeg' ? 'jpg' : 'pdf';
            const notificationMessage = fileExtension.toUpperCase() + '로 생성 중입니다...';
            showNotification(notificationMessage, 2000);
            
            const reportContent = document.getElementById('report-content-to-capture');
            const allTabs = reportContent.querySelectorAll('.tab-content');
            allTabs.forEach(tab => tab.style.display = 'block');

            try {
                const canvas = await html2canvas(reportContent, {
                    scale: 2,
                    backgroundColor: getComputedStyle(document.body).getPropertyValue('--bg-color')
                });

                const reportTitle = (document.getElementById('report-title').textContent || 'AcTi_Report').replace(/\s+/g, '_');

                if (format === 'jpeg') {
                    const link = document.createElement('a');
                    link.href = canvas.toDataURL('image/jpeg', 0.9);
                    link.download = `${reportTitle}.jpg`;
                    document.body.appendChild(link);
                    link.click();
                    document.body.removeChild(link);
                } else { // PDF
                    const { jsPDF } = window.jspdf;
                    const pdf = new jsPDF('p', 'mm', 'a4');

                    const canvasWidth = canvas.width;
                    const canvasHeight = canvas.height;

                    const pdfWidth = pdf.internal.pageSize.getWidth();
                    const pdfHeight = pdf.internal.pageSize.getHeight();

                    const ratio = pdfWidth / canvasWidth;
                    const pageCanvasHeight = pdfHeight / ratio; 

                    let yPosition = 0;
                    let pageCount = 1;

                    while (yPosition < canvasHeight) {
                        if (pageCount > 1) {
                            pdf.addPage();
                        }
                        
                        const sliceHeight = Math.min(pageCanvasHeight, canvasHeight - yPosition);
                        
                        const tempCanvas = document.createElement('canvas');
                        tempCanvas.width = canvasWidth;
                        tempCanvas.height = sliceHeight;
                        const tempCtx = tempCanvas.getContext('2d');
                        
                        tempCtx.drawImage(canvas, 0, yPosition, canvasWidth, sliceHeight, 0, 0, canvasWidth, sliceHeight);
                        
                        const imageData = tempCanvas.toDataURL('image/png', 1.0);
                        pdf.addImage(imageData, 'PNG', 0, 0, pdfWidth, sliceHeight * ratio);
                        
                        yPosition += pageCanvasHeight;
                        pageCount++;
                    }
                    pdf.save(`${reportTitle}.pdf`);
                }
                
                showNotification(fileExtension.toUpperCase() + ' 다운로드가 시작되었습니다.', 3000);

            } catch (error) {
                console.error(`리포트 ${format} 저장 오류:`, error);
                showNotification(`${format.toUpperCase()} 생성에 실패했습니다.`, 3000);
            } finally {
                 allTabs.forEach(tab => {
                     if(!tab.classList.contains('active')) {
                         tab.style.display = 'none';
                     }
                 });
            }
        }
        
        saveJpgBtn.addEventListener('click', () => captureReport('jpeg'));
        savePdfBtn.addEventListener('click', () => captureReport('pdf'));


        function displayReport(report) {
            const sceneOverview = report.sceneOverview || {};
            const characterProfile = report.characterProfile || {};
            const relationshipDynamics = report.relationshipDynamics || {};
            const keyLines = report.keyLines || [];
            const directorsView = report.directorsView || {};
            
            currentColorScheme = sceneOverview.colors || [];

            document.getElementById('report-title').textContent = report.title || "AcTi 분석 리포트";
            document.getElementById('report-character-name').textContent = report.character || '캐릭터';

            document.getElementById('report-atmosphere-keywords').innerHTML = (sceneOverview.atmosphereKeywords || []).map(k => `<span class="keyword">#${k}</span>`).join('');
            document.getElementById('report-color-palette').innerHTML = (currentColorScheme).map(c => `<div class="color-chip" style="background-color: ${c.hex};"></div>`).join('');
            document.getElementById('report-scene-function').textContent = sceneOverview.sceneFunction || '내용 없음';
            document.getElementById('report-conflict-summary').textContent = sceneOverview.conflictSummary || '내용 없음';

            document.getElementById('report-objective').textContent = characterProfile.objective || '내용 없음';
            document.getElementById('report-obstacle').textContent = characterProfile.obstacle || '내용 없음';
            document.getElementById('report-subtext').textContent = characterProfile.subtext || '내용 없음';
            document.getElementById('report-action-verbs').textContent = (characterProfile.actionVerbs || []).join(', ');
            drawEmotionGraph(characterProfile.emotionalJourney);

            const keyLinesEl = document.getElementById('report-key-lines');
            keyLinesEl.innerHTML = '';
            keyLines.forEach(item => {
                const lineItem = document.createElement('div');
                lineItem.className = 'line-coaching-item';
                lineItem.innerHTML = `<p class="line-text">"${item.line || ''}"</p><div class="coaching-details"><p><strong>의도:</strong> ${item.intention || ''}</p><p><strong>어조:</strong> ${item.tone || ''}</p><p><strong>템포:</strong> ${item.tempo || ''}</p><p><strong>호흡/멈춤:</strong> ${item.pause || ''}</p></div>`;
                keyLinesEl.appendChild(lineItem);
            });

            // Display detailed relationships
            const relationshipsContainer = document.getElementById('report-relationships-container');
            relationshipsContainer.innerHTML = ''; // Clear previous content
            if (relationshipDynamics.detailedRelationships && relationshipDynamics.detailedRelationships.length > 0) {
                relationshipDynamics.detailedRelationships.forEach(rel => {
                    const card = document.createElement('div');
                    card.className = 'analysis-card relationship-card';
                    
                    const particle = getKoreanParticle(rel.otherCharacter || '');
                    
                    card.innerHTML = `
                        <h4>${rel.otherCharacter}${particle}의 관계</h4>
                        <table class="relationship-table">
                            <tbody>
                                <tr>
                                    <td>관계 정의</td>
                                    <td>${rel.relationship || '분석 정보 없음'}</td>
                                </tr>
                                <tr>
                                    <td>주요 역학</td>
                                    <td>${rel.dynamics || '분석 정보 없음'}</td>
                                </tr>
                            </tbody>
                        </table>
                    `;
                    relationshipsContainer.appendChild(card);
                });
            }

            document.getElementById('report-power-dynamics').textContent = relationshipDynamics.powerDynamicsSummary || '내용 없음';
            
            // Director's View
            document.getElementById('director-writer-intent').textContent = directorsView.writerIntent || '내용 없음';
            document.getElementById('director-core-theme').textContent = directorsView.coreTheme || '내용 없음';
            document.getElementById('director-scene-structure').textContent = directorsView.sceneStructure || '내용 없음';
            document.getElementById('director-suggestions').textContent = directorsView.directorialSuggestions || '내용 없음';

            const balanceStart = relationshipDynamics.balanceStart || 0;
            const balanceEnd = relationshipDynamics.balanceEnd || 0;
            const startEl = document.getElementById('balance-start');
            const endEl = document.getElementById('balance-end');
            
            startEl.style.width = '0%'; 
            endEl.style.width = '0%';
            setTimeout(() => {
                startEl.style.width = `${balanceStart}%`;
                endEl.style.width = `${balanceEnd}%`;
            }, 100);
        }
        
        // Modal Event Listeners
        function setupModal(modal) {
            const closeBtns = modal.querySelectorAll('.modal-close-btn');
            const hide = () => modal.classList.remove('show');
            closeBtns.forEach(btn => btn.addEventListener('click', hide));
            modal.addEventListener('click', (e) => {
                if (e.target === modal) hide();
            });
            return { show: () => modal.classList.add('show'), hide };
        }
        
        const colorModalController = setupModal(colorModal);
        const matchingChoiceModalController = setupModal(matchingChoiceModal);
        const matchingResultModalController = setupModal(matchingResultModal);
        const qaModalController = setupModal(qaModal);

        showColorMeaningBtn.addEventListener('click', () => {
            if (currentColorScheme.length > 0) {
                modalColorContent.innerHTML = currentColorScheme.map(c => `
                    <div class="color-meaning-item">
                        <div class="color-chip" style="background-color: ${c.hex};"></div>
                        <p>${c.meaning}</p>
                    </div>
                `).join('');
                colorModalController.show();
            } else {
                showNotification("컬러 분석 정보가 없습니다.", 2000);
            }
        });
        
        // Korean Particle Logic
        function getKoreanParticle(name) {
            if (!name) return '와';
            const lastChar = name.charCodeAt(name.length - 1);
            if (lastChar < 0xAC00 || lastChar > 0xD7A3) {
                return '와'; 
            }
            return (lastChar - 0xAC00) % 28 > 0 ? '과' : '와';
        }

        // Matching Feature Logic
        matchingBtn.addEventListener('click', () => {
            if (currentMatchingReport && lastMatchedImage) {
                displayMatchingResult(currentMatchingReport, lastMatchedImage);
                matchingResultModalController.show();
            } else {
                 matchingChoiceModalController.show();
            }
        });
        
        matchingGalleryInput.addEventListener('change', (e) => handleMatchingImage(e.target.files[0]));
        matchingCameraInput.addEventListener('change', (e) => handleMatchingImage(e.target.files[0]));

        async function handleMatchingImage(file) {
            if (!file) return;
            matchingChoiceModalController.hide();
            
            const resultContainer = document.getElementById('matching-result-content');
            resultContainer.innerHTML = `<div class="loading-text">배우 이미지 분석 중...</div>`;
            matchingResultModalController.show();
            
            try {
                const base64Data = await readFileAsBase64(file);
                lastMatchedImage = `data:${file.type};base64,${base64Data}`;
                await startImageMatchingAnalysis(base64Data);
            } catch (error) {
                console.error("이미지 매칭 오류:", error);
                resultContainer.innerHTML = `<p>오류가 발생했습니다: ${error.message}</p>`;
            }
        }

        async function startImageMatchingAnalysis(base64Image) {
            if (!currentAnalysisReport || !currentAnalysisReport.characterProfile) {
                throw new Error("먼저 대본 분석을 완료해야 합니다.");
            }
            
            const systemPrompt = `You are a professional and seasoned casting director AI. Your task is to analyze an actor's photo and provide a sophisticated comparison with a provided character profile from a script. Your analysis must be nuanced, constructive, and deeply insightful, as if you were making a critical casting decision for a major film. All text must be in Korean.

**Your Analysis Must Include:**
- **matchPercentage:** An integer from 0 to 100. This is not a simple visual match. It's a holistic assessment of the actor's potential to embody the character's *essence*, considering their look, the character's core psychology (objective, subtext, emotional journey), and overall atmospheric fit. Base this on a careful, nuanced judgment.
- **imageAnalysis:** A professional assessment of the actor's image. Analyze their facial expression, gaze, overall mood, and what kind of stories or emotions their face conveys. What is their "type"? What roles would they typically be cast for based on this single image?
- **strengths:** What aspects of the actor's look (e.g., intense eyes, a vulnerable quality, a hint of arrogance) align well with the character's detailed profile? Be specific and connect the visual evidence to the character's inner life.
- **improvements:** Constructive feedback for the actor. What aspects might they need to develop or suppress to better embody this specific character? This should be about performance and physical expression, not just appearance (e.g., "To capture the character's anxiety, a more grounded posture and tension in the jaw would be essential.").
- **stylingSuggestions:** This is a crucial section. As a director consulting with hair, makeup, and wardrobe departments, provide highly detailed and specific recommendations.
    - **hair:** Suggest a specific style, color, and condition (e.g., "Slightly unkempt, shoulder-length dark brown hair, perhaps with a few grey streaks to show world-weariness.").
    - **makeup:** Describe the makeup approach. (e.g., "Minimal, naturalistic makeup, focusing on emphasizing under-eye circles to show fatigue, and chapped lips to suggest neglect.").
    - **costume:** Recommend a specific costume concept with textures and colors. (e.g., "A faded, oversized wool sweater over a simple cotton shirt, in muted earth tones like olive and grey, to convey a sense of comfort but also of being worn down by the world.").`;

            const characterProfileText = JSON.stringify(currentAnalysisReport.characterProfile);

            const payload = {
                contents: [{
                    parts: [
                        { text: `Here is the character profile:\n${characterProfileText}\n\nNow, analyze this actor's photo and provide a casting analysis.` },
                        { inline_data: { mime_type: "image/jpeg", data: base64Image } }
                    ]
                }],
                systemInstruction: { parts: [{ text: systemPrompt }] },
                generationConfig: {
                    responseMimeType: "application/json",
                    responseSchema: {type: 'OBJECT', properties: {matchPercentage: {type: 'NUMBER'}, imageAnalysis: {type: 'STRING'}, strengths: {type: 'STRING'}, improvements: {type: 'STRING'}, stylingSuggestions: {type: 'OBJECT', properties: {hair: {type: 'STRING'}, makeup: {type: 'STRING'}, costume: {type: 'STRING'}}}}}
                }
            };

            const result = await callGeminiAPI(payload);
            const matchingData = JSON.parse(result.candidates[0].content.parts[0].text);
            currentMatchingReport = matchingData;
            displayMatchingResult(matchingData, lastMatchedImage);
        }

        function displayMatchingResult(data, imageUrl) {
             const resultContainer = document.getElementById('matching-result-content');
             const percentage = data.matchPercentage || 0;
             const radius = 50;
             const circumference = 2 * Math.PI * radius;
             const offset = circumference - (percentage / 100) * circumference;
             const styling = data.stylingSuggestions || {};

             resultContainer.innerHTML = `
                <div class="matching-result-header">
                     <img src="${imageUrl}" alt="매칭 이미지" style="max-width: 100px; max-height: 100px; border-radius: 8px; margin-bottom: 15px;">
                    <div class="progress-circle-container">
                        <svg width="120" height="120" viewBox="0 0 120 120">
                            <circle class="progress-circle-bg" cx="60" cy="60" r="${radius}" stroke-width="10"></circle>
                            <circle class="progress-circle-bar" cx="60" cy="60" r="${radius}" stroke-width="10" stroke-dasharray="${circumference}" stroke-dashoffset="${circumference}"></circle>
                            <text x="50%" y="50%" dy=".3em" class="progress-circle-text">${percentage}%</text>
                        </svg>
                    </div>
                    <p>캐릭터 매칭률</p>
                </div>
                <div class="analysis-card">
                    <h4>이미지 총평</h4>
                    <p>${data.imageAnalysis || '분석 정보 없음'}</p>
                </div>
                <div class="analysis-card">
                    <h4>강점</h4>
                    <p>${data.strengths || '분석 정보 없음'}</p>
                </div>
                <div class="analysis-card">
                    <h4>보완점</h4>
                    <p>${data.improvements || '분석 정보 없음'}</p>
                </div>
                 <div class="analysis-card">
                    <h4>스타일링 제언</h4>
                     <table class="relationship-table">
                        <tbody>
                            <tr>
                                <td>헤어</td>
                                <td>${styling.hair || '분석 정보 없음'}</td>
                            </tr>
                            <tr>
                                <td>메이크업</td>
                                <td>${styling.makeup || '분석 정보 없음'}</td>
                            </tr>
                            <tr>
                                <td>의상</td>
                                <td>${styling.costume || '분석 정보 없음'}</td>
                            </tr>
                        </tbody>
                    </table>
                </div>
             `;
             
             // Animate progress circle
             setTimeout(() => {
                resultContainer.querySelector('.progress-circle-bar').style.strokeDashoffset = offset;
             }, 100);
        }
        
        // Q&A Feature Logic
        qaBtn.addEventListener('click', () => qaModalController.show());
        const qaSubmitBtn = document.getElementById('qa-submit-btn');
        const qaInput = document.getElementById('qa-input');
        const qaAnswerArea = document.getElementById('qa-answer-area');

        qaSubmitBtn.addEventListener('click', async () => {
            const question = qaInput.value.trim();
            if (!question) {
                showNotification("질문을 입력해주세요.", 2000);
                return;
            }
            if (!currentAnalysisReport) {
                showNotification("먼저 대본 분석을 완료해야 합니다.", 3000);
                return;
            }

            qaAnswerArea.innerHTML = `<div class="loading-text">AI가 답변을 생성 중입니다...</div>`;
            qaSubmitBtn.disabled = true;

            try {
                const systemPrompt = `You are 'AcTi', the AI script analysis expert who generated the provided analysis. A user is asking a follow-up question. Based on the original script and the detailed analysis you've already created (both provided below), answer the user's question in a helpful, insightful, and professional manner. Your answer must be in Korean.`;
                const fullContext = `Original Script:\n---\n${scriptInput.value.trim()}\n---\n\nYour Previous Analysis:\n---\n${JSON.stringify(currentAnalysisReport)}\n---\n\nUser's Question:\n---\n${question}\n---`;

                const payload = {
                    contents: [{ parts: [{ text: fullContext }] }],
                    systemInstruction: { parts: [{ text: systemPrompt }] }
                };
                
                const result = await callGeminiAPI(payload);
                const answer = result.candidates[0].content.parts[0].text;
                qaAnswerArea.innerHTML = `<p>${answer.replace(/\n/g, '<br>')}</p>`;

            } catch (error) {
                 console.error("Q&A 오류:", error);
                 qaAnswerArea.innerHTML = `<p>답변 생성 중 오류가 발생했습니다: ${error.message}</p>`;
            } finally {
                qaSubmitBtn.disabled = false;
            }
        });



        function drawEmotionGraph(data) {
            const svg = document.getElementById('reportEmotionGraph'); 
            const tableContainer = document.getElementById('emotion-table-container');
            if (!svg || !tableContainer || !data || data.length === 0) {
                if(svg) svg.innerHTML = '';
                if(tableContainer) tableContainer.innerHTML = '';
                return;
            }

            svg.innerHTML = ''; 
            tableContainer.innerHTML = '';
            
            const axisColor = '#555';
            svg.innerHTML += `<line x1="0" y1="50" x2="100" y2="50" stroke="${axisColor}" stroke-width="0.3"/><line x1="0" y1="0" x2="0" y2="50" stroke="${axisColor}" stroke-width="0.3"/>`;
            
            let pathD = "M";
            
            const pointCount = data.length;
            const spacing = pointCount > 1 ? 90 / (pointCount - 1) : 0;
            const startX = 5;

            data.forEach((point, index) => {
                let intensity = point.intensity || 0;
                if (intensity > 0 && intensity <= 1) {
                    intensity = Math.round(intensity * 100);
                }
                const x = pointCount === 1 ? 50 : startX + (index * spacing);
                const y = 50 - (intensity / 2);
                pathD += (index === 0 ? '' : ' L ') + `${x} ${y}`;
                
                const text = document.createElementNS("http://www.w3.org/2000/svg", "text");
                text.setAttribute("x", x);
                text.setAttribute("y", y - 3); 
                text.setAttribute("font-size", "4");
                text.setAttribute("fill", "var(--primary-yellow)");
                text.setAttribute("text-anchor", "middle");
                text.textContent = index + 1;
                svg.appendChild(text);

                const circle = document.createElementNS("http://www.w3.org/2000/svg", "circle");
                circle.setAttribute("cx", x); circle.setAttribute("cy", y); circle.setAttribute("r", "2");
                circle.setAttribute("fill", "var(--primary-yellow)"); circle.setAttribute("stroke", "var(--bg-color)"); circle.setAttribute("stroke-width", "0.5");
                const title = document.createElementNS("http://www.w3.org/2000/svg", "title");
                title.textContent = `${index+1}. 감정: ${point.emotion} (강도: ${intensity}%)\n대사: "${point.line}"`;
                circle.appendChild(title);
                svg.appendChild(circle);
            });

            if(data && data.length > 0) {
                const path = document.createElementNS("http://www.w3.org/2000/svg", "path");
                path.setAttribute("d", pathD); path.setAttribute("fill", "none");
                path.setAttribute("stroke", "rgba(255, 214, 10, 0.7)"); path.setAttribute("stroke-width", "1.5");
                svg.appendChild(path);

                const table = document.createElement('table');
                table.className = 'emotion-table';
                table.innerHTML = `<thead><tr><th style="width:10%">번호</th><th>핵심 대사</th><th>감정 변화</th></tr></thead>`;
                const tbody = document.createElement('tbody');
                data.forEach((point, index) => {
                    let intensity = point.intensity || 0;
                     if (intensity > 0 && intensity <= 1) {
                        intensity = Math.round(intensity * 100);
                    }
                    const row = document.createElement('tr');
                    row.innerHTML = `<td class="point-number">${index + 1}</td><td>"${point.line}"</td><td>${point.emotion} (강도 ${intensity}%)</td>`;
                    tbody.appendChild(row);
                });
                table.appendChild(tbody);
                tableContainer.appendChild(table);
            }
        }
    });
</script>
</body>
</html>

