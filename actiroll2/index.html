<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>AcTi 롤모델 - AI 배우 분석 리포트</title>
    <!-- 홈 화면 아이콘 설정 -->
    <link rel="apple-touch-icon" href="actiroll.png">
    <link rel="icon" type="image/png" href="actiroll.png">
    
    <script src="https://cdn.tailwindcss.com"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/html2canvas/1.4.1/html2canvas.min.js"></script>
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Playfair+Display:wght@700&family=Noto+Sans+KR:wght@300;400;500;700&display=swap" rel="stylesheet">
    <style>
        :root {
            --bg-main: #FDF8F0; /* Warm, elegant off-white */
            --text-primary: #4E443C; /* Dark, warm brown for headings */
            --text-secondary: #71665D; /* Slightly lighter for body text */
            --accent-color: #6B5B4B; /* Muted, sophisticated brown for buttons/accents */
            --border-color: #E5E0D9;
        }
        body { font-family: 'Noto Sans KR', sans-serif; background-color: var(--bg-main); color: var(--text-secondary); }
        h1, h2, h3, h4, h5, .font-serif { font-family: 'Playfair Display', serif; color: var(--text-primary); }
        .accent-text { color: var(--accent-color); }
        .accent-bg { background-color: var(--accent-color); }
        
        #report-content ::-webkit-scrollbar, #qna-chatbox::-webkit-scrollbar, #scene-content::-webkit-scrollbar, #tips-content::-webkit-scrollbar { width: 8px; }
        #report-content ::-webkit-scrollbar-track, #qna-chatbox::-webkit-scrollbar-track, #scene-content::-webkit-scrollbar-track, #tips-content::-webkit-scrollbar-track { background: #EFEAE4; }
        #report-content ::-webkit-scrollbar-thumb, #qna-chatbox::-webkit-scrollbar-thumb, #scene-content::-webkit-scrollbar-thumb, #tips-content::-webkit-scrollbar-thumb { background-color: #D1C9BF; border-radius: 10px; }
        #report-content ::-webkit-scrollbar-thumb:hover, #qna-chatbox::-webkit-scrollbar-thumb:hover, #scene-content::-webkit-scrollbar-thumb:hover, #tips-content::-webkit-scrollbar-thumb:hover { background-color: #BDB2A7; }

        .fade-in-up { animation: fadeInUp 0.8s ease-out forwards; opacity: 0; }
        @keyframes fadeInUp {
            from { opacity: 0; transform: translateY(20px); }
            to { opacity: 1; transform: translateY(0); }
        }
        
        .ai-generated-content h2, .ai-generated-content h3 { font-family: 'Playfair Display', serif; color: var(--text-primary); margin-bottom: 0.75rem; }
        .ai-generated-content h2 { font-size: 1.75rem; margin-top: 2rem; padding-bottom: 0.5rem; border-bottom: 1px solid var(--border-color); }
        .ai-generated-content h3 { font-size: 1.25rem; margin-top: 1.5rem; }
        .ai-generated-content p { line-height: 1.7; margin-bottom: 1rem; }
        .ai-generated-content ul { list-style-type: disc; list-style-position: outside; padding-left: 1.5rem; margin-bottom: 1rem; }
        .ai-generated-content li { margin-bottom: 0.5rem; padding-left: 0.5rem; }
        .ai-generated-content li::marker { color: var(--accent-color); }
        .ai-generated-content strong { color: var(--text-primary); font-weight: 500; }
        .ai-generated-content p:last-child { margin-bottom: 0; }
        .ai-generated-content em { font-style: italic; color: var(--text-secondary); }

        .finder-option-button.selected {
            background-color: var(--accent-color);
            color: white;
            border-color: var(--accent-color);
        }
    </style>
</head>
<body class="antialiased">

    <!-- Header -->
    <header class="p-6 md:p-8 border-b sticky top-0 bg-[var(--bg-main)] z-10" style="border-color: var(--border-color);">
        <div class="container mx-auto flex justify-between items-center">
            <div class="flex items-center gap-3">
                 <img src="actiroll.png" alt="AcTi Logo" class="h-10 w-10 rounded-full object-cover bg-stone-200 border border-stone-300">
                 <h1 class="text-2xl md:text-3xl tracking-wider">AcTi 롤모델</h1>
            </div>
            <div class="flex items-center space-x-2 md:space-x-4">
                 <button id="finder-button" title="롤모델 찾기" class="accent-bg text-white rounded-full p-2.5 hover:opacity-90 transition-opacity">
                     <svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M18 20a2 2 0 0 0 2-2V8a2 2 0 0 0-2-2h-2.172a2 2 0 0 1-1.414-.586l-.828-.828A2 2 0 0 0 12.172 4H6a2 2 0 0 0-2 2v12a2 2 0 0 0 2 2Z"/><circle cx="12" cy="13" r="3"/></svg>
                 </button>
                 <button id="save-jpg-button" title="리포트 저장하기" class="accent-bg text-white rounded-full p-2.5 hover:opacity-90 transition-all disabled:opacity-40 disabled:cursor-not-allowed">
                     <svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 15v4a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2v-4"></path><polyline points="7 10 12 15 17 10"></polyline><line x1="12" y1="15" x2="12" y2="3"></line></svg>
                 </button>
                 <button id="qna-button" title="AcTi Q&A" class="accent-bg text-white rounded-full p-2.5 hover:opacity-90 transition-opacity">
                     <svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 15a2 2 0 0 1-2 2H7l-4 4V5a2 2 0 0 1 2-2h14a2 2 0 0 1 2 2z"></path></svg>
                 </button>
            </div>
        </div>
    </header>

    <main id="main-content" class="container mx-auto p-6 md:p-12">
        <section id="search-section" class="text-center transition-opacity duration-700 fade-in-up">
            <h2 class="text-4xl md:text-6xl mb-4">The Actor's Dossier</h2>
            <p class="mb-10 max-w-2xl mx-auto">분석하고 싶은 배우의 이름을 입력하세요.<br>AcTi가 그의 모든 것을 분석하여, 당신을 위한 정밀 리포트를 생성합니다.</p>
            <div class="max-w-xl mx-auto flex items-center gap-2 p-2 bg-white rounded-full shadow-md border" style="border-color: var(--border-color);">
                <input type="text" id="actor-search-input" class="w-full py-3 px-5 bg-transparent text-lg focus:outline-none" placeholder="예: 이병헌, 전도연, 최민식" style="color: var(--text-primary);">
                <button id="search-button" class="accent-bg text-white rounded-full p-3 hover:opacity-90 transition-opacity"><svg width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><circle cx="11" cy="11" r="8"/><line x1="21" y1="21" x2="16.65" y2="16.65"/></svg></button>
            </div>
        </section>

        <section id="finder-results-section" class="hidden text-center transition-opacity duration-700"></section>
        <section id="disambiguation-section" class="hidden text-center transition-opacity duration-700"></section>
        
        <section id="loading-section" class="hidden text-center transition-opacity duration-500">
            <div class="flex flex-col items-center justify-center min-h-[50vh]">
                 <div class="w-16 h-16 border-4 border-stone-200 rounded-full animate-spin" style="border-top-color: var(--accent-color);"></div>
                 <h3 class="text-3xl mt-8">AcTi가 분석 중입니다...</h3>
                 <p id="loading-status" class="mt-2">잠시만 기다려주세요.</p>
            </div>
        </section>

        <section id="error-section" class="hidden my-8 transition-opacity duration-500">
             <div class="max-w-2xl mx-auto bg-red-50 border border-red-200 text-red-800 px-4 py-3 rounded-lg" role="alert">
                 <strong class="font-bold font-serif" id="error-title">분석 오류!</strong>
                 <p id="error-message">오류가 발생했습니다.</p>
             </div>
        </section>

        <section id="report-section" class="hidden"></section>
    </main>
    
    <!-- All Modals -->
    <div id="finder-modal" class="hidden fixed inset-0 bg-black bg-opacity-60 flex items-center justify-center p-4 z-50">
        <div class="bg-white rounded-lg shadow-xl w-full max-w-2xl max-h-[80vh] flex flex-col" style="background-color: var(--bg-main);">
            <header class="p-4 border-b flex justify-between items-center" style="border-color: var(--border-color);"><h3 class="text-2xl font-serif">나의 롤모델 찾기</h3><button id="close-finder-modal" class="p-2 -mr-2 text-2xl leading-none text-stone-500 hover:text-stone-800">&times;</button></header>
            <div class="flex-1 p-6 overflow-y-auto space-y-6">
                <div>
                    <h4 class="font-bold mb-2 text-primary">성별</h4>
                    <div id="finder-gender" class="flex gap-2">
                        <button class="finder-option-button w-full bg-white text-stone-700 py-2 rounded-full border hover:bg-stone-50" data-group="gender">남자</button>
                        <button class="finder-option-button w-full bg-white text-stone-700 py-2 rounded-full border hover:bg-stone-50" data-group="gender">여자</button>
                    </div>
                </div>
                 <div>
                    <h4 class="font-bold mb-2 text-primary">연령대</h4>
                    <div id="finder-age" class="grid grid-cols-3 gap-2">
                        <button class="finder-option-button bg-white text-stone-700 py-2 rounded-full border hover:bg-stone-50" data-group="age">10대</button>
                        <button class="finder-option-button bg-white text-stone-700 py-2 rounded-full border hover:bg-stone-50" data-group="age">20대</button>
                        <button class="finder-option-button bg-white text-stone-700 py-2 rounded-full border hover:bg-stone-50" data-group="age">30대</button>
                        <button class="finder-option-button bg-white text-stone-700 py-2 rounded-full border hover:bg-stone-50" data-group="age">40대</button>
                        <button class="finder-option-button bg-white text-stone-700 py-2 rounded-full border hover:bg-stone-50" data-group="age">50대 이상</button>
                    </div>
                </div>
                 <div>
                    <h4 class="font-bold mb-2 text-primary">연기 스타일 (최대 3개 선택)</h4>
                    <div id="finder-style" class="grid grid-cols-2 sm:grid-cols-3 gap-2">
                         <button class="finder-option-button bg-white text-stone-700 py-2 rounded-full border hover:bg-stone-50" data-group="style">메소드 연기</button>
                         <button class="finder-option-button bg-white text-stone-700 py-2 rounded-full border hover:bg-stone-50" data-group="style">캐릭터 연기</button>
                         <button class="finder-option-button bg-white text-stone-700 py-2 rounded-full border hover:bg-stone-50" data-group="style">자연스러운 생활 연기</button>
                         <button class="finder-option-button bg-white text-stone-700 py-2 rounded-full border hover:bg-stone-50" data-group="style">강렬한 카리스마</button>
                         <button class="finder-option-button bg-white text-stone-700 py-2 rounded-full border hover:bg-stone-50" data-group="style">코미디/희극 연기</button>
                         <button class="finder-option-button bg-white text-stone-700 py-2 rounded-full border hover:bg-stone-50" data-group="style">선 굵은 액션 연기</button>
                    </div>
                </div>
            </div>
            <footer class="p-4 border-t bg-white text-center" style="border-color: var(--border-color);">
                <button id="find-rolemodels-button" class="w-full accent-bg text-white rounded-full py-3 px-5 hover:opacity-90 transition-opacity">AcTi! 롤모델 추천해줘</button>
            </footer>
        </div>
    </div>
    <div id="qna-modal" class="hidden fixed inset-0 bg-black bg-opacity-60 flex items-center justify-center p-4 z-50">
        <div class="bg-white rounded-lg shadow-xl w-full max-w-2xl max-h-[80vh] flex flex-col" style="background-color: var(--bg-main);">
            <header class="p-4 border-b flex justify-between items-center" style="border-color: var(--border-color);"><h3 class="text-2xl font-serif">AcTi Q&A</h3><button id="close-qna-modal" class="p-2 -mr-2 text-2xl leading-none text-stone-500 hover:text-stone-800">&times;</button></header>
            <div id="qna-chatbox" class="flex-1 p-4 overflow-y-auto space-y-4">
                 <div class="flex items-start gap-3">
                    <div class="accent-bg text-white text-sm rounded-full h-8 w-8 flex-shrink-0 flex items-center justify-center font-bold">A</div>
                    <div class="bg-white rounded-lg p-3 max-w-lg shadow-sm border ai-generated-content" style="border-color: var(--border-color);"><p class="text-sm">배우 분석이나 연기에 대해 궁금한 점을 질문해주세요.</p></div>
                </div>
            </div>
            <footer class="p-4 border-t bg-white" style="border-color: var(--border-color);">
                <form id="qna-form" class="flex items-center gap-2">
                    <input type="text" id="qna-input" class="w-full py-2 px-4 bg-gray-100 rounded-full focus:outline-none" placeholder="AcTi에게 질문하기..."><button type="submit" class="accent-bg text-white rounded-full p-3 hover:opacity-90"><svg width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><path d="m22 2-7 20-4-9-9-4Z"/><path d="M22 2 11 13"/></svg></button>
                </form>
            </footer>
        </div>
    </div>
    <div id="scene-modal" class="hidden fixed inset-0 bg-black bg-opacity-60 flex items-center justify-center p-4 z-50">
        <div id="scene-to-capture" class="bg-white rounded-lg shadow-xl w-full max-w-2xl max-h-[80vh] flex flex-col" style="background-color: var(--bg-main);">
            <header class="p-4 border-b flex justify-between items-center" style="border-color: var(--border-color);">
                <div class="flex items-center gap-3">
                    <h3 class="text-2xl font-serif">✨ 맞춤 오디션 대본</h3>
                    <button id="get-acting-tips-button" title="연기 팁 보기" class="text-yellow-500 hover:text-yellow-400 transition-colors"><svg width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><path d="M15.09 16.05a1 1 0 0 1-1.42 1.42l-1.6-1.6a1 1 0 0 1 0-1.41l8.59-8.6a1 1 0 0 1 1.41 0zM12 22s-8-4.5-8-11.8A8 8 0 0 1 12 2a8 8 0 0 1 8 8.2c0 1.42-.23 2.82-.67 4.15"/></svg></button>
                </div>
                <button id="close-scene-modal" class="p-2 -mr-2 text-2xl leading-none">&times;</button>
            </header>
            <div id="scene-content" class="flex-1 p-6 overflow-y-auto ai-generated-content"></div>
            <footer class="p-4 border-t bg-white" style="border-color: var(--border-color);">
                 <form id="scene-edit-form" class="flex items-center gap-2 mb-3">
                    <input type="text" id="scene-edit-input" class="w-full py-2 px-4 bg-gray-100 rounded-full focus:outline-none" placeholder="대본 수정 요청하기 (예: 더 차갑게)"><button type="submit" class="accent-bg text-white rounded-full p-3 hover:opacity-90"><svg width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><path d="M21.174 6.812a1 1 0 0 0-3.986-3.987L3.842 16.174a2 2 0 0 0-.5.83l-1.321 4.352a.5.5 0 0 0 .623.622l4.353-1.32a2 2 0 0 0 .83-.498z"/><path d="m15 5 4 4"/></svg></button>
                </form>
                <button id="save-scene-button" class="w-full bg-stone-200 text-stone-700 rounded-full py-2 px-5 hover:bg-stone-300">JPG로 저장하기</button>
            </footer>
        </div>
    </div>
    <div id="tips-modal" class="hidden fixed inset-0 bg-black bg-opacity-60 flex items-center justify-center p-4 z-50">
        <div id="tips-to-capture" class="bg-white rounded-lg shadow-xl w-full max-w-2xl max-h-[80vh] flex flex-col" style="background-color: var(--bg-main);">
            <header class="p-4 border-b flex justify-between items-center" style="border-color: var(--border-color);">
                <h3 class="text-2xl font-serif">💡 AcTi 연기 코칭</h3>
                <button id="close-tips-modal" class="p-2 -mr-2 text-2xl leading-none">&times;</button>
            </header>
            <div id="tips-content" class="flex-1 p-6 overflow-y-auto ai-generated-content"></div>
            <footer class="p-4 border-t bg-white text-center" style="border-color: var(--border-color);">
                <button id="save-tips-button" class="w-full bg-stone-200 text-stone-700 rounded-full py-2 px-5 hover:bg-stone-300">JPG로 저장하기</button>
            </footer>
        </div>
    </div>

    <script>
        // --- CONFIGURATION ---
        const API_KEY = "AIzaSyBbEsfDqt5ojPAJoo70Nozro4LacKk__4k"; 

        // --- DOM ELEMENTS ---
        const searchSection = document.getElementById('search-section');
        const searchInput = document.getElementById('actor-search-input');
        const searchButton = document.getElementById('search-button');
        const disambiguationSection = document.getElementById('disambiguation-section');
        const loadingSection = document.getElementById('loading-section');
        const loadingStatus = document.getElementById('loading-status');
        const errorSection = document.getElementById('error-section');
        const errorMessageEl = document.getElementById('error-message');
        const reportSection = document.getElementById('report-section');
        const finderResultsSection = document.getElementById('finder-results-section');
        const saveJpgButton = document.getElementById('save-jpg-button');
        const qnaButton = document.getElementById('qna-button');
        const qnaModal = document.getElementById('qna-modal');
        const closeQnaModalButton = document.getElementById('close-qna-modal');
        const qnaForm = document.getElementById('qna-form');
        const qnaInput = document.getElementById('qna-input');
        const qnaChatbox = document.getElementById('qna-chatbox');
        const sceneModal = document.getElementById('scene-modal');
        const closeSceneModalButton = document.getElementById('close-scene-modal');
        const sceneContent = document.getElementById('scene-content');
        const saveSceneButton = document.getElementById('save-scene-button');
        const sceneEditForm = document.getElementById('scene-edit-form');
        const sceneEditInput = document.getElementById('scene-edit-input');
        const tipsModal = document.getElementById('tips-modal');
        const closeTipsModalButton = document.getElementById('close-tips-modal');
        const tipsContent = document.getElementById('tips-content');
        const saveTipsButton = document.getElementById('save-tips-button');
        const finderModal = document.getElementById('finder-modal');
        const closeFinderModalButton = document.getElementById('close-finder-modal');
        const finderButton = document.getElementById('finder-button');
        const findRoleModelsButton = document.getElementById('find-rolemodels-button');
        const getActingTipsButton = document.getElementById('get-acting-tips-button');
        
        // --- GLOBAL STATE ---
        let currentActor = { name: null, reportHtml: null };
        saveJpgButton.disabled = true;
        
        // --- UTILITY FUNCTIONS ---
        function hideAllSections() {
            [searchSection, disambiguationSection, loadingSection, errorSection, reportSection, finderResultsSection].forEach(s => s.classList.add('hidden'));
        }
        function showSearchSection() {
            hideAllSections();
            searchInput.value = '';
            searchSection.classList.remove('hidden');
            saveJpgButton.disabled = true;
        }
        function showError(message) {
            hideAllSections();
            errorMessageEl.textContent = `오류가 발생했습니다: ${message}. 다른 배우로 시도하거나 잠시 후 다시 시도해주세요.`;
            errorSection.classList.remove('hidden');
            searchSection.classList.remove('hidden');
        }

        // --- CORE LOGIC ---
        async function fetchWithRetry(url, options, retries = 3, delay = 1000) {
            for (let i = 0; i < retries; i++) {
                try {
                    const response = await fetch(url, options);
                    if (response.status >= 500 && response.status < 600) { throw new Error(`Server error: ${response.status}`); }
                    return response;
                } catch (error) {
                    if (i === retries - 1) { console.error("Fetch failed:", error); throw error; }
                    await new Promise(res => setTimeout(res, delay));
                    delay *= 2;
                }
            }
        }

        async function callGenerativeApi(systemPrompt, userQuery) {
            const apiUrl = `https://generativelanguage.googleapis.com/v1beta/models/gemini-2.5-flash-preview-05-20:generateContent?key=${API_KEY}`;
            const payload = { contents: [{ parts: [{ text: userQuery }] }], systemInstruction: { parts: [{ text: systemPrompt }] } };
            const response = await fetchWithRetry(apiUrl, { method: 'POST', headers: { 'Content-Type': 'application/json' }, body: JSON.stringify(payload) });
            
            if (!response.ok) {
                const errorBody = await response.json();
                console.error("AcTi API Error:", errorBody);
                throw new Error(`AcTi API 호출 실패: ${errorBody.error?.message || response.status}`);
            }

            const result = await response.json();
            const candidate = result.candidates?.[0];
            const text = candidate?.content?.parts?.[0]?.text;

            if (!text || (candidate && candidate.finishReason && candidate.finishReason !== "STOP")) {
                 let reason = candidate?.finishReason || '알 수 없음';
                 if (candidate?.finishReason === 'SAFETY') { reason = '안전 설정에 의해 차단됨'; }
                 throw new Error(`콘텐츠 생성 실패 (사유: ${reason})`);
            }
            return text;
        }

        async function generateAIReport(actorName) {
            const systemPrompt = `당신은 '배우가 배우를 연구하는' 관점을 지닌 세계 최고의 연기 코치입니다. 당신의 임무는 단순한 정보 요약이 아니라, 배우 지망생이 주어진 배우를 '롤모델'로서 철저히 분석하고, 그의 연기 기술과 커리어 전략을 자신의 것으로 만들 수 있도록 돕는 것입니다. 최신 뉴스를 검색하는 것이 아니라, 그의 연기 본질과 성장 과정을 분석하여 '따라 배울 점'을 명확히 제시해야 합니다. 최종 결과물은 다른 설명 없이 오직 리포트 내용이 담긴 단일 HTML 문자열이어야 합니다. <h2>, <h3>, <p>, <ul>, <li>, <strong> 같은 태그를 사용하여 내용을 구조화하세요. 전체 응답은 이 HTML 문자열이어야 하며, 마크다운 형식(\`\`\`)으로 감싸지 마세요. 보고서 전체에서 'AI'라는 단어 대신 'AcTi'를 사용하세요. 리포트에는 반드시 다음의 관점이 포함되어야 합니다: 1. **롤모델로서의 핵심 가치**: 왜 이 배우를 롤모델로 삼아야 하는가? 그의 어떤 점이 다른 배우와 차별화되는가? 2. **'훔치고 싶은' 연기 기술**: 그의 대표적인 연기 테크닉(시선 처리, 목소리 톤, 감정의 완급 조절 등)을 구체적인 작품 장면을 예로 들어 분석하고, 어떻게 훈련해야 하는지 설명. 3. **현명한 커리어 설계**: 그의 필모그래피가 어떻게 그의 페르소나를 구축했는지, 그리고 작품 선택의 기준이 무엇인지 분석하여, 배우 지망생이 자신의 커리어를 어떻게 설계해야 할지에 대한 통찰을 제공. 4. **내면을 지배하는 연기 철학**: 그의 인터뷰나 행보를 통해 드러난 연기에 대한 태도와 마인드셋을 분석하고, 이것이 그의 연기에 어떻게 반영되는지 설명. 5. **나만의 것으로 만드는 Action Plan**: '이 배우처럼 되기 위해' 내일부터 당장 실천할 수 있는 구체적이고 단계적인 훈련 방법을 제시. (예: 특정 영화의 독백 100번 따라하기, 그의 인터뷰 영상 필사하기 등)`;
            const userQuery = `'${actorName}' 배우에 대한 롤모델 분석 리포트를 HTML 형식으로 생성해줘.`;
            return await callGenerativeApi(systemPrompt, userQuery);
        }
        
        async function fetchActorImage(actorName, qid = null) {
            const encodedName = encodeURIComponent(actorName || '');
            const placeholderUrl = `https://placehold.co/160x160/E5E0D9/4E443C?text=${encodedName}`;
            try {
                let fileName;
                if (qid) {
                    const qidApiUrl = `https://www.wikidata.org/w/api.php?action=wbgetentities&ids=${qid}&format=json&props=claims&origin=*`;
                    const qidResponse = await fetch(qidApiUrl);
                    if (qidResponse.ok) {
                        const qidData = await qidResponse.json();
                        const imageClaim = qidData.entities[qid].claims?.P18;
                        if (imageClaim?.[0]) {
                            fileName = imageClaim[0].mainsnak.datavalue.value;
                        }
                    }
                }
                
                if(!fileName && actorName) {
                    for (const lang of ['ko', 'en']) {
                         try {
                            const wikiUrl = `https://${lang}.wikipedia.org/api/rest_v1/page/summary/${encodedName}`;
                            const response = await fetch(wikiUrl);
                            if (response.ok) {
                                const data = await response.json();
                                if (data.originalimage?.source) {
                                     const urlParts = data.originalimage.source.split('/');
                                     const decodedFileName = decodeURIComponent(urlParts[urlParts.length - 1]);
                                     if(data.originalimage.source.includes('commons')){
                                         fileName = decodedFileName;
                                         break;
                                     }
                                     return data.originalimage.source;
                                }
                            }
                        } catch (e) {}
                    }
                }

                if (fileName) {
                    const imageInfoUrl = `https://commons.wikimedia.org/w/api.php?action=query&titles=File:${encodeURIComponent(fileName)}&prop=imageinfo&iiprop=url&format=json&origin=*`;
                    const imageInfoResponse = await fetch(imageInfoUrl);
                    if (imageInfoResponse.ok) {
                        const imageInfoData = await imageInfoResponse.json();
                        const pages = imageInfoData.query.pages;
                        const pageId = Object.keys(pages)[0];
                        if (pageId !== "-1" && pages[pageId].imageinfo) {
                            return pages[pageId].imageinfo[0].url;
                        }
                    }
                }
            } catch (error) { console.error("Image fetch error:", error); }
            return placeholderUrl;
        }

        async function searchAndDisambiguate(actorName) {
            hideAllSections();
            loadingSection.classList.remove('hidden');
            loadingStatus.textContent = `'${actorName}' 검색 중...`;
            try {
                const encodedName = encodeURIComponent(actorName);
                const url = `https://www.wikidata.org/w/api.php?action=wbsearchentities&search=${encodedName}&language=ko&format=json&props=description&type=item&origin=*`;
                const response = await fetch(url);
                const data = await response.json();
                const actors = (data.search || []).filter(item => {
                    if (!item.description) return false;
                    const desc = item.description.toLowerCase();
                    return desc.includes('배우') || desc.includes('actor') || desc.includes('actress') || desc.includes('연기자');
                });
                if (actors.length === 0) { throw new Error(`'${actorName}'에 대한 배우 정보를 찾을 수 없습니다.`); }
                else if (actors.length === 1) { await generateReport(actors[0].label, actors[0].id); }
                else { displayDisambiguation(actors); }
            } catch (error) { showError(error.message); }
            finally { loadingSection.classList.add('hidden'); }
        }
        function displayDisambiguation(actors) {
            hideAllSections();
            let content = `<h2 class="text-3xl md:text-4xl mb-4">동명이인 배우</h2><p class="mb-8">분석하고 싶은 배우를 선택해주세요.</p><div class="grid grid-cols-2 md:grid-cols-4 gap-4">`;
            actors.forEach(actor => {
                const placeholderUrl = `https://placehold.co/200x300/E5E0D9/4E443C?text=${encodeURIComponent(actor.label)}`;
                content += `<div class="actor-card cursor-pointer p-2 bg-white/50 rounded-lg hover:shadow-lg transition-shadow" data-name="${actor.label}" data-qid="${actor.id}"><img src="${placeholderUrl}" data-qid="${actor.id}" class="w-full h-48 object-cover rounded-md mb-2 bg-stone-200" alt="${actor.label}"><h4 class="font-bold text-primary">${actor.label}</h4><p class="text-sm text-secondary">${actor.description || ''}</p></div>`;
            });
            content += `</div>`;
            disambiguationSection.innerHTML = content;
            disambiguationSection.classList.remove('hidden');
            document.querySelectorAll('.actor-card').forEach(card => {
                const qid = card.dataset.qid;
                const img = card.querySelector('img');
                fetchActorImage(null, qid).then(url => img.src = url);
                card.addEventListener('click', () => { generateReport(card.dataset.name, card.dataset.qid); });
            });
        }
        async function generateReport(actorName, qid) {
            hideAllSections();
            loadingSection.classList.remove('hidden');
            const loadingMessages = ["프로필 사진 검색 중...", "리포트 생성 중...", "AcTi가 데이터를 분석하고 있습니다..."];
            let msgIndex = 0;
            const interval = setInterval(() => { loadingStatus.textContent = loadingMessages[msgIndex++ % loadingMessages.length]; }, 2000);
            try {
                const imageUrl = await fetchActorImage(actorName, qid);
                const reportHtml = await generateAIReport(actorName);
                currentActor = { name: actorName, reportHtml: reportHtml };
                displayReport(imageUrl);
            } catch (error) { showError(error.message); }
            finally { clearInterval(interval); loadingSection.classList.add('hidden'); }
        }
        function displayReport(imageUrl) {
            const { name, reportHtml } = currentActor;
            const finalReportHtml = reportHtml || `<p class="text-center text-red-600">오류: 리포트 내용을 표시할 수 없습니다.</p>`;
            reportSection.innerHTML = `
                <div id="report-to-capture" class="bg-white rounded-lg shadow-xl p-8 md:p-12 border fade-in-up">
                    <button id="back-to-search" class="accent-bg text-white text-sm py-2 px-4 rounded-full mb-8 hover:opacity-90">← 다른 배우 분석하기</button>
                    <header class="text-center mb-12">
                        <img src="${imageUrl}" alt="${name}" class="w-40 h-40 object-cover rounded-full mx-auto mb-4 shadow-lg border-4" style="border-color: var(--border-color);" onerror="this.onerror=null;this.src='https://placehold.co/160x160/E5E0D9/4E443C?text=${encodeURIComponent(name)}';">
                        <h1 class="text-5xl mb-2 font-serif">${name}</h1>
                        <h2 class="text-2xl text-stone-500 font-serif tracking-widest mt-2">롤모델 분석 REPORT</h2>
                    </header>
                    <div id="report-content" class="ai-generated-content">${finalReportHtml}</div>
                    <div class="mt-12 text-center">
                        <button id="toggle-scene-options-button" class="accent-bg text-white font-bold py-3 px-6 rounded-full hover:opacity-90 text-lg">✨ 맞춤 대본 생성하기</button>
                        <div id="scene-options" class="hidden mt-4 grid grid-cols-2 sm:grid-cols-4 gap-2 max-w-lg mx-auto">
                           <button class="scene-genre-button bg-stone-100 text-stone-700 py-2 rounded-full hover:bg-stone-200">배우 강점 극대화</button>
                           <button class="scene-genre-button bg-stone-100 text-stone-700 py-2 rounded-full hover:bg-stone-200">일상</button>
                           <button class="scene-genre-button bg-stone-100 text-stone-700 py-2 rounded-full hover:bg-stone-200">감성/슬픔</button>
                           <button class="scene-genre-button bg-stone-100 text-stone-700 py-2 rounded-full hover:bg-stone-200">로맨스</button>
                           <button class="scene-genre-button bg-stone-100 text-stone-700 py-2 rounded-full hover:bg-stone-200">코믹/밝음</button>
                           <button class="scene-genre-button bg-stone-100 text-stone-700 py-2 rounded-full hover:bg-stone-200">장르/어두움</button>
                           <button class="scene-genre-button bg-stone-100 text-stone-700 py-2 rounded-full hover:bg-stone-200">스릴러</button>
                           <button class="scene-genre-button bg-stone-100 text-stone-700 py-2 rounded-full hover:bg-stone-200">사극</button>
                        </div>
                    </div>
                </div>`;
            reportSection.classList.remove('hidden');
            saveJpgButton.disabled = false;
            document.getElementById('back-to-search').addEventListener('click', showSearchSection);
            document.getElementById('toggle-scene-options-button').addEventListener('click', () => document.getElementById('scene-options').classList.toggle('hidden'));
            document.querySelectorAll('.scene-genre-button').forEach(button => {
                button.addEventListener('click', () => generateAuditionScene(name, reportHtml, button.textContent));
            });
        }
        async function captureAndSave(elementId, fileName, buttonId) {
            const elementToCapture = document.getElementById(elementId);
            const button = document.getElementById(buttonId);
            if (!elementToCapture || !button) return;
            button.disabled = true;
            const originalButtonText = button.textContent;
            button.textContent = '이미지 생성 중...';
            const originalMaxHeight = elementToCapture.style.maxHeight;
            elementToCapture.style.maxHeight = 'none';
            try {
                await new Promise(resolve => setTimeout(resolve, 100));
                const canvas = await html2canvas(elementToCapture, { scale: 3, useCORS: true, backgroundColor: getComputedStyle(elementToCapture).getPropertyValue('background-color') });
                const link = document.createElement('a');
                link.download = fileName;
                link.href = canvas.toDataURL('image/jpeg', 0.95);
                link.click();
            } catch (err) { console.error("JPG 저장 오류:", err); alert("이미지 저장에 실패했습니다."); }
            finally {
                elementToCapture.style.maxHeight = originalMaxHeight;
                button.disabled = false;
                button.textContent = originalButtonText;
            }
        }
        async function generateAuditionScene(actorName, reportHtml, genre, existingScene = null, editRequest = null) {
            sceneModal.classList.remove('hidden');
            sceneContent.innerHTML = `<div class="flex items-center justify-center h-full"><div class="w-12 h-12 border-4 border-stone-200 rounded-full animate-spin" style="border-top-color: var(--accent-color);"></div></div>`;
            saveSceneButton.disabled = true;
            let systemPrompt, userQuery;
            if (existingScene && editRequest) {
                systemPrompt = `당신은 창의적인 시나리오 작가입니다. 주어진 대본을 사용자의 요청에 맞게 수정합니다. 반드시 이전 대본의 맥락과 형식을 유지하면서, 요청사항만 반영하여 완성된 전체 대본을 다시 제공해야 합니다. 최종 결과물은 다른 설명 없이 오직 완성된 대본 HTML 문자열이어야 합니다. 코드 블록 마커나 불필요한 설명을 절대 포함하지 마세요.`;
                userQuery = `기존 대본:\n\n${existingScene}\n\n사용자 수정 요청: "${editRequest}"\n\n위 요청을 반영하여 전체 대본을 수정해주세요.`;
            } else {
                const tempDiv = document.createElement('div');
                tempDiv.innerHTML = reportHtml;
                const reportText = (tempDiv.textContent || "").replace(/\s\s+/g, ' ').substring(0, 1500);
                systemPrompt = `당신은 창의적인 시나리오 작가입니다. 배우 지망생을 위해, 특정 배우의 강점을 극대화할 수 있는 **1분~1분 30초 분량의 오디션용 장면**을 작성합니다. 최종 결과물은 실제 대본처럼 서식이 지정된, 순수한 단일 HTML 문자열이어야 합니다. 코드 블록 마커(\`\`\`)를 절대 포함하지 마세요. 다음 규칙을 엄격히 준수하세요: 1. **창의성**: 매번 이전과는 다른 독창적인 상황을 구상해야 합니다. 배우의 가장 대표적인 이미지만 반복하는 것이 아니라, 그의 다른 작품이나 알려지지 않은 매력을 탐구하여 신선한 캐릭터와 배경을 창조해야 합니다. 2. **분량**: 대사량이 충분하여 배우가 1분 이상 연기할 수 있도록 작성해야 합니다. 3. **지문**: 대사 안의 연기 지문은 <em>(괄호 안에)</em> 이탤릭체로 작성하되, **길고 서술적인 설명은 피하고, 행동이나 감정의 핵심만 간결하게** 표현해야 합니다. (예: '<em>(잠시 침묵)</em>', '<em>(목소리가 살짝 떨리며)</em>'). 4. **언어**: 인물 설명과 이름은 오직 한글로만 작성하세요. 5. **대본 형식**: 인물 이름은 <strong> 태그를 사용하여 볼드체로, 대사는 다음 줄에 들여쓰기 된 형식으로 제공해야 합니다. (예: '<p><strong>김영감</strong></p><p style="padding-left: 1.5rem;">...대사...</p>'). 6. **줄바꿈**: 긴 대사는 의미 단위로 <br> 태그를 사용하여 가독성을 높여주세요.`;
                userQuery = `다음은 '${actorName}' 배우에 대한 분석입니다. 이 분석을 바탕으로, **'${genre}' 스타일**을 강조하여 그의 연기력을 가장 잘 보여줄 수 있는 **1분~1분 30초 분량**의 오리지널 오디션 장면을 HTML 형식으로 작성해주세요.\n\n분석 내용: "${reportText}"`;
            }
            try {
                const sceneHtml = await callGenerativeApi(systemPrompt, userQuery);
                sceneContent.innerHTML = sceneHtml;
                saveSceneButton.disabled = false;
            } catch (error) { sceneContent.innerHTML = `<p class="text-red-700 text-center">죄송합니다. 대본을 생성하는 중에 오류가 발생했습니다: ${error.message}</p>`; }
        }
        async function generateActingTips(actorName, sceneHtml) {
            tipsModal.classList.remove('hidden');
            tipsContent.innerHTML = `<div class="flex items-center justify-center h-full"><div class="w-12 h-12 border-4 border-stone-200 rounded-full animate-spin" style="border-top-color: var(--accent-color);"></div></div>`;
            const systemPrompt = `당신은 'AcTi' 연기 코치입니다. 서론이나 결론, 인사 없이 바로 핵심 연기 팁 분석으로 들어가세요. 주어진 대본과 롤모델 배우 정보를 바탕으로, 배우 지망생이 연기 연습에 바로 적용할 수 있는 구체적이고 실질적인 코칭을 제공합니다. 롤모델 배우라면 이 장면을 어떻게 해석하고 표현할지, 그의 스타일을 어떻게 녹여낼 수 있을지 상세히 설명해주세요. (예: '${actorName}' 배우 특유의 시선 처리, 목소리 톤, 침묵 활용법 등). 최종 결과물은 오직 연기 팁에 대한 내용만 담긴 HTML 문자열이어야 합니다. <h3>, <p>, <ul>, <li>, <strong> 태그를 사용하여 내용을 구조화하고, 마크다운 형식은 절대 사용하지 마세요.`;
            const userQuery = `이 오디션 대본은 '${actorName}' 배우를 롤모델로 삼는 학생을 위한 것입니다. '${actorName}' 배우의 입장에서 이 대본을 어떻게 연기해야 할지에 대한 구체적이고 전문적인 연기 팁을 HTML 형식으로 작성해주세요.\n\n대본:\n${sceneHtml}`;
            try {
                const tipsHtml = await callGenerativeApi(systemPrompt, userQuery);
                tipsContent.innerHTML = tipsHtml;
            } catch (error) { tipsContent.innerHTML = `<p class="text-red-700 text-center">죄송합니다. 연기 팁을 생성하는 중에 오류가 발생했습니다: ${error.message}</p>`; }
        }
        async function getQnaResponse(question) { 
            const systemPrompt = "당신은 'AcTi'라는 이름을 가진 연기 전문 코치입니다. 배우 지망생의 질문에 대해 다른 인사나 마무리 멘트 없이 핵심적인 답변만 간결하고 전문적으로 제공하세요. 당신의 이름은 'AcTi'이며, 'AI'라는 단어는 절대 사용하지 마세요. 답변은 항상 한국어로 제공해야 합니다. 최종 결과물은 다른 설명 없이 오직 답변 내용이 담긴 단일 HTML 문자열이어야 합니다. <p>, <ul>, <li>, <strong> 태그를 사용하여 가독성 좋게 내용을 구조화하고, 섹션을 구분해주세요. 마크다운 형식(**)은 절대 사용하지 마세요.";
            return await callGenerativeApi(systemPrompt, question);
        }
        function appendMessage(sender, message) {
            const isUser = sender === 'user';
            const messageHtml = isUser ? `<div class="flex items-start gap-3 justify-end"><div class="bg-accent-color text-white rounded-lg p-3 max-w-lg shadow-sm"><p class="text-sm"><strong class="font-bold text-white/80">Q.</strong> ${message}</p></div></div>` : `<div class="flex items-start gap-3"><div class="accent-bg text-white text-sm rounded-full h-8 w-8 flex-shrink-0 flex items-center justify-center font-bold">A</div><div class="bg-white rounded-lg p-3 max-w-lg shadow-sm border text-sm ai-generated-content" style="border-color: var(--border-color);">${message}</div></div>`;
            qnaChatbox.innerHTML += messageHtml;
            qnaChatbox.scrollTop = qnaChatbox.scrollHeight;
        }
        async function findRoleModels() {
            finderModal.classList.add('hidden');
            hideAllSections();
            loadingSection.classList.remove('hidden');
            loadingStatus.textContent = `나의 성향을 분석하여 롤모델을 찾는 중...`;
            const selectedGender = document.querySelector('#finder-gender .selected')?.textContent;
            const selectedAge = document.querySelector('#finder-age .selected')?.textContent;
            const selectedStyles = [...document.querySelectorAll('#finder-style .selected')].map(el => el.textContent);
            const systemPrompt = `당신은 세계 최고의 캐스팅 디렉터 AcTi입니다. 사용자가 선택한 조건(성별, 연령대, 연기 스타일)에 맞는 대한민국 배우 5명을 추천합니다. 최종 결과는 다른 설명 없이 오직 JSON 배열 형식이어야 합니다. 각 객체는 'name'과 'description' 키를 가져야 합니다. 예: [{"name": "송강호", "description": "1967년생 대한민국 남자 배우"}, ...]`;
            let userQuery = "다음 조건에 맞는 롤모델 배우 5명을 추천해줘:\n";
            if (selectedGender) userQuery += `- 성별: ${selectedGender}\n`;
            if (selectedAge) userQuery += `- 연령대: ${selectedAge}\n`;
            if (selectedStyles.length > 0) userQuery += `- 연기 스타일: ${selectedStyles.join(', ')}\n`;
            try {
                const resultText = await callGenerativeApi(systemPrompt, userQuery);
                const startIndex = resultText.indexOf('[');
                const endIndex = resultText.lastIndexOf(']');
                if (startIndex === -1 || endIndex === -1) { throw new Error("AcTi가 유효한 배우 목록을 생성하지 못했습니다."); }
                const jsonString = resultText.substring(startIndex, endIndex + 1);
                const actors = JSON.parse(jsonString);
                displayFinderResults(actors);
            } catch (error) { showError(`롤모델 추천 생성에 실패했습니다. ${error.message}`); }
            finally { loadingSection.classList.add('hidden'); }
        }
        function displayFinderResults(actors) {
            hideAllSections();
            let content = `<h2 class="text-3xl md:text-4xl mb-4">AcTi 추천 롤모델</h2><p class="mb-8">나의 성향과 잘 맞는 롤모델 배우입니다.</p><div class="grid grid-cols-2 md:grid-cols-4 gap-4">`;
            actors.forEach(actor => {
                const placeholderUrl = `https://placehold.co/200x300/E5E0D9/4E443C?text=${encodeURIComponent(actor.name)}`;
                content += `<div class="actor-card cursor-pointer p-2 bg-white/50 rounded-lg hover:shadow-lg transition-shadow" data-name="${actor.name}"><img src="${placeholderUrl}" class="w-full h-48 object-cover rounded-md mb-2 bg-stone-200" alt="${actor.name}"><h4 class="font-bold text-primary">${actor.name}</h4><p class="text-sm text-secondary">${actor.description || ''}</p></div>`;
            });
            content += `</div>`;
            finderResultsSection.innerHTML = content;
            finderResultsSection.classList.remove('hidden');
            document.querySelectorAll('.actor-card').forEach(card => {
                const img = card.querySelector('img');
                const actorName = card.dataset.name;
                fetchActorImage(actorName).then(url => img.src = url);
                card.addEventListener('click', () => { searchAndDisambiguate(actorName); });
            });
        }
        
        // --- EVENT LISTENERS ---
        function setupEventListeners() {
            searchButton.addEventListener('click', () => {
                const actorName = searchInput.value.trim();
                if (actorName) searchAndDisambiguate(actorName);
            });
            searchInput.addEventListener('keyup', (event) => {
                if (event.key === 'Enter') {
                    const actorName = searchInput.value.trim();
                    if (actorName) searchAndDisambiguate(actorName);
                }
            });

            saveJpgButton.addEventListener('click', () => captureAndSave('report-to-capture', `AcTi_Report_${currentActor.name}.jpg`, 'save-jpg-button'));
            saveSceneButton.addEventListener('click', () => captureAndSave('scene-to-capture', `AcTi_Scene_${currentActor.name}.jpg`, 'save-scene-button'));
            saveTipsButton.addEventListener('click', () => captureAndSave('tips-to-capture', `AcTi_Tips_${currentActor.name}.jpg`, 'save-tips-button'));

            qnaButton.addEventListener('click', () => qnaModal.classList.remove('hidden'));
            closeQnaModalButton.addEventListener('click', () => qnaModal.classList.add('hidden'));
            
            closeSceneModalButton.addEventListener('click', () => sceneModal.classList.add('hidden'));
            getActingTipsButton.addEventListener('click', () => {
                const sceneHtml = sceneContent.innerHTML;
                if (currentActor.name && sceneHtml) generateActingTips(currentActor.name, sceneHtml);
            });
            
            closeTipsModalButton.addEventListener('click', () => tipsModal.classList.add('hidden'));

            finderButton.addEventListener('click', () => finderModal.classList.remove('hidden'));
            closeFinderModalButton.addEventListener('click', () => finderModal.classList.add('hidden'));
            findRoleModelsButton.addEventListener('click', findRoleModels);

            document.querySelectorAll('.finder-option-button').forEach(button => {
                button.addEventListener('click', () => {
                    const group = button.dataset.group;
                    if (group === 'style') {
                        const selectedCount = document.querySelectorAll(`#finder-style .selected`).length;
                        if (button.classList.contains('selected')) {
                            button.classList.remove('selected');
                        } else if (selectedCount < 3) {
                            button.classList.add('selected');
                        }
                    } else {
                        document.querySelectorAll(`[data-group="${group}"]`).forEach(btn => btn.classList.remove('selected'));
                        button.classList.add('selected');
                    }
                });
            });

            qnaForm.addEventListener('submit', async (e) => { 
                e.preventDefault();
                const question = qnaInput.value.trim();
                if (!question) return;
                appendMessage('user', question);
                qnaInput.value = '';
                qnaForm.querySelector('button').disabled = true;
                try {
                    const response = await getQnaResponse(question);
                    appendMessage('acti', response);
                } catch(error) {
                    appendMessage('acti', `오류가 발생했습니다: ${error.message}`);
                } finally {
                    qnaForm.querySelector('button').disabled = false;
                }
            });
            
            sceneEditForm.addEventListener('submit', (e) => {
                e.preventDefault();
                const editRequest = sceneEditInput.value.trim();
                if (!editRequest) return;
                const existingScene = sceneContent.innerHTML;
                generateAuditionScene(currentActor.name, null, '수정', existingScene, editRequest);
                sceneEditInput.value = '';
            });
        }
        
        setupEventListeners();
    </script>
</body>
</html>

