<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    
    <!-- í™ˆ í™”ë©´ ì•± ëª¨ë“œ ì„¤ì • (ì£¼ì†Œì°½ ìˆ¨ê¸°ê¸°) -->
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
    <meta name="apple-mobile-web-app-title" content="ëŒ€ìˆœì˜ì–´">

    <title>ëŒ€ìˆœì˜ì–´ (AI Ver.)</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.5.1/css/all.min.css">
    <link href="https://fonts.googleapis.com/css2?family=Noto+Sans+KR:wght@400;500;700;900&display=swap" rel="stylesheet">
    <style>
        html, body {
            height: 100%;
            overflow: hidden;
        }
        body {
            font-family: 'Noto Sans KR', sans-serif;
            touch-action: manipulation;
            background: #0F0C29;
            background: -webkit-linear-gradient(to right, #24243E, #302B63, #0F0C29);
            background: linear-gradient(to right, #24243E, #302B63, #0F0C29);
        }
        .glass {
            background: rgba(255, 255, 255, 0.05);
            backdrop-filter: blur(12px);
            -webkit-backdrop-filter: blur(12px);
            border: 1px solid rgba(255, 255, 255, 0.1);
        }
        .sentence-block {
            cursor: grab;
            transition: all 0.2s ease-in-out;
            touch-action: none; /* í„°ì¹˜ ì´ë²¤íŠ¸ ì§ì ‘ ì œì–´ */
        }
        .sentence-block:active {
            cursor: grabbing;
        }
        .dragging { 
            opacity: 0.5; 
            transform: scale(1.05);
            z-index: 1000;
            box-shadow: 0 0 25px rgba(124, 58, 237, 0.6);
        }
        
        .neon-blue { box-shadow: 0 0 5px #60a5fa, 0 0 10px #60a5fa; }
        .neon-red { box-shadow: 0 0 5px #f87171, 0 0 10px #f87171; }
        .neon-green { box-shadow: 0 0 5px #4ade80, 0 0 10px #4ade80; }

        @keyframes popIn { 0% { transform: scale(0.8); opacity: 0; } 100% { transform: scale(1); opacity: 1; } }
        @keyframes shake { 0%, 100% { transform: translateX(0); } 10%, 30%, 50%, 70%, 90% { transform: translateX(-8px); } 20%, 40%, 60%, 80% { transform: translateX(8px); } }
        .feedback-correct { animation: popIn 0.5s ease; }
        .feedback-incorrect { animation: shake 0.5s ease; }
        @keyframes slideUp { from { transform: translateY(100%); opacity: 0; } to { transform: translateY(0); opacity: 1; } }
        .bottom-sheet { animation: slideUp 0.5s cubic-bezier(0.25, 0.46, 0.45, 0.94); }
        .loader { border: 4px solid #4a5568; border-top: 4px solid #a78bfa; border-radius: 50%; width: 50px; height: 50px; animation: spin 1s linear infinite; }
        @keyframes spin { 0% { transform: rotate(0deg); } 100% { transform: rotate(360deg); } }
        
        #xp-bar-fill { transition: width 0.5s ease-in-out; }
        .autopsy-placeholder { transition: opacity 0.3s ease; }
        .speaker-icon {
            transition: color 0.2s ease-in-out;
        }
        /* Toggle Switch */
        .toggle-checkbox:checked + .toggle-label {
            background-color: #4f46e5; /* indigo-600 */
        }
        .toggle-checkbox:checked + .toggle-label .toggle-ball {
            transform: translateX(100%);
        }
        .mode-label {
            transition: all 0.3s ease;
        }
    </style>
</head>
<body class="text-gray-200 flex flex-col h-screen">

    <header class="text-center pt-5 pb-3 px-4 flex-shrink-0">
        <div class="flex justify-between items-center w-full max-w-3xl mx-auto">
            <div id="level-indicator" class="text-lg font-bold bg-violet-500 text-white rounded-full px-4 py-1.5 flex items-center gap-2">
                <i class="fa-solid fa-star"></i>
                <span>Lv. <span id="level">1</span></span>
            </div>
            <h1 class="text-2xl font-black text-white tracking-tighter">ëŒ€ìˆœì˜ì–´</h1>
            <div id="streak-counter" class="text-lg font-bold bg-amber-500 text-gray-900 rounded-full px-4 py-1.5 flex items-center gap-2">
                <i class="fa-solid fa-fire"></i>
                <span id="streak-count">0</span>
            </div>
        </div>
        <div id="xp-bar" class="w-full max-w-3xl mx-auto mt-3 h-2.5 bg-gray-700 rounded-full">
            <div id="xp-bar-fill" class="h-2.5 bg-gradient-to-r from-violet-500 to-fuchsia-500 rounded-full" style="width: 0%"></div>
        </div>
    </header>

    <main class="flex-grow flex flex-col justify-center px-4 overflow-y-auto">
        <div class="w-full max-w-3xl mx-auto mb-4 flex justify-center items-center gap-3">
             <span id="mode-label-ai" class="mode-label">ëŒ€ìˆœ's ì¶”ì²œ</span>
             <label for="mode-toggle" class="flex items-center cursor-pointer">
                <div class="relative">
                    <input type="checkbox" id="mode-toggle" class="sr-only toggle-checkbox">
                    <div class="toggle-label block bg-gray-600 w-14 h-8 rounded-full"></div>
                    <div class="toggle-ball absolute left-1 top-1 bg-white w-6 h-6 rounded-full transition-transform"></div>
                </div>
            </label>
            <span id="mode-label-past" class="mode-label">ğŸ”¥ ê¸°ì¶œ ë¶„ì„</span>
        </div>
        
        <div id="loader-container" class="my-8 flex justify-center items-center flex-col">
            <div class="loader"></div>
            <p id="loader-text" class="mt-4 text-violet-400 font-semibold text-lg flex items-center gap-2"></p>
        </div>
        
        <div id="main-content" class="hidden w-full max-w-3xl mx-auto">
            <div id="question-source" class="text-center font-bold text-cyan-400 mb-4 h-6"></div>
            <div class="my-6">
                <h2 class="font-bold text-gray-400 mb-3 text-center text-lg flex items-center justify-center gap-2"><i class="fa-solid fa-puzzle-piece"></i> ë¬¸ì¥ ì¬ë£Œë“¤: ì—¬ê¸°ì„œ ë¼ˆëŒ€ë¥¼ ë°œê³¨í•´ë´!</h2>
                <div id="block-tray" class="block-tray p-4 rounded-xl border-2 border-gray-700 flex flex-wrap gap-3 justify-center items-center glass"></div>
            </div>

            <div class="mb-6">
                <h2 class="font-bold text-gray-400 mb-3 text-center text-lg flex items-center justify-center gap-2"><i class="fa-solid fa-microscope"></i> í•´ë¶€ì‹¤: <span class="text-red-400">'ë¼ˆëŒ€'</span>ë§Œ ì˜¬ë ¤ë´!</h2>
                <div id="autopsy-table" class="autopsy-table p-4 rounded-xl border-2 border-violet-700 flex flex-wrap gap-3 justify-center items-center glass relative">
                    <div id="autopsy-placeholder" class="autopsy-placeholder absolute inset-0 flex flex-col items-center justify-center text-gray-600 pointer-events-none">
                        <i class="fa-solid fa-hand-pointer text-4xl mb-2"></i>
                        <span class="font-semibold">ì´ê³³ìœ¼ë¡œ ë¼ˆëŒ€ë¥¼ ì˜®ê²¨ë´!</span>
                    </div>
                </div>
            </div>
            
            <div id="feedback-container" class="mt-4 h-12 flex items-center justify-center"></div>
        </div>
    </main>
    
    <footer id="action-bar" class="flex-shrink-0 p-4 w-full max-w-3xl mx-auto hidden">
         <div class="flex gap-3">
            <button id="check-btn" class="w-full bg-gradient-to-r from-violet-600 to-indigo-600 hover:from-violet-700 hover:to-indigo-700 text-white font-bold py-3.5 px-4 rounded-xl text-lg shadow-lg transform transition-transform hover:scale-105 disabled:opacity-50 disabled:cursor-not-allowed">
                <i class="fa-solid fa-check"></i> ë¼ˆëŒ€ í™•ì¸!
            </button>
            <button id="next-btn" class="w-full bg-gray-700 hover:bg-gray-600 text-white font-bold py-3.5 px-4 rounded-xl text-lg shadow-lg transform transition-transform hover:scale-105">
                <i class="fa-solid fa-arrow-right"></i> ë‹¤ìŒ ë¬¸ì œ
            </button>
        </div>
    </footer>

    <div id="explanation-sheet" class="hidden fixed inset-0 z-10">
        <div class="absolute inset-0 bg-black/70" id="explanation-backdrop"></div>
        <div id="explanation-content" class="bottom-sheet absolute bottom-0 left-0 right-0 glass rounded-t-2xl p-6 w-full max-w-3xl mx-auto">
            <h3 id="explanation-title" class="font-black text-2xl bg-clip-text text-transparent bg-gradient-to-r from-amber-400 to-orange-500 mb-3 text-center flex items-center justify-center gap-2"><i class="fa-solid fa-pen-to-square"></i> ëŒ€ìˆœ's Point! ì§šê³  ê°€ê¸°!</h3>
            <div class="bg-gray-900/50 text-gray-300 p-4 rounded-lg">
                <p id="explanation-text" class="text-lg leading-relaxed"></p>
                <div id="takeaway-container" class="mt-4 pt-4 border-t border-gray-700">
                    <h4 class="font-bold text-amber-400 flex items-center gap-2"><i class="fa-solid fa-key"></i>ì´ê²ƒë§Œ ê¸°ì–µí•´!</h4>
                    <p id="takeaway-text" class="italic"></p>
                </div>
            </div>
            <div class="mt-4 flex flex-col sm:flex-row gap-3">
                <button id="similar-sentence-btn" class="w-full bg-gradient-to-r from-teal-500 to-cyan-500 hover:from-teal-600 hover:to-cyan-600 text-white font-bold py-3 px-4 rounded-xl text-lg shadow-lg transform transition-transform hover:scale-105">
                    <i class="fa-solid fa-wand-magic-sparkles"></i> ì´ ë¬¸ë²•ìœ¼ë¡œ ë” í›ˆë ¨í•˜ê¸°
                </button>
                 <button id="analyze-mistake-btn" class="w-full bg-gradient-to-r from-rose-500 to-pink-500 hover:from-rose-600 hover:to-pink-600 text-white font-bold py-3 px-4 rounded-xl text-lg shadow-lg transform transition-transform hover:scale-105 hidden">
                    <i class="fa-solid fa-magnifying-glass-chart"></i> ë‚´ ë‹µì•ˆ ë¶„ì„ ìš”ì²­
                </button>
            </div>
            <button id="close-explanation-btn" class="absolute top-4 right-4 text-gray-500 hover:text-white text-2xl">
                <i class="fa-solid fa-xmark"></i>
            </button>
        </div>
    </div>

    <script>
        let currentSentence;
        let lastIncorrectAnswer = null;
        let draggedBlock = null;
        let streak = 0;
        let level = 1;
        let xp = 0;
        const xpPerLevel = 100;

        const apiKey = "AIzaSyBbEsfDqt5ojPAJoo70Nozro4LacKk__4k";

        const mainContent = document.getElementById('main-content');
        const loaderContainer = document.getElementById('loader-container');
        const loaderText = document.getElementById('loader-text');
        const actionBar = document.getElementById('action-bar');
        const blockTray = document.getElementById('block-tray');
        const autopsyTable = document.getElementById('autopsy-table');
        const autopsyPlaceholder = document.getElementById('autopsy-placeholder');
        const checkBtn = document.getElementById('check-btn');
        const nextBtn = document.getElementById('next-btn');
        const feedbackContainer = document.getElementById('feedback-container');
        
        const streakCountEl = document.getElementById('streak-count');
        const levelEl = document.getElementById('level');
        const xpBarFill = document.getElementById('xp-bar-fill');

        const explanationSheet = document.getElementById('explanation-sheet');
        const explanationTitle = document.getElementById('explanation-title');
        const explanationText = document.getElementById('explanation-text');
        const takeawayContainer = document.getElementById('takeaway-container');
        const takeawayText = document.getElementById('takeaway-text');
        const closeExplanationBtn = document.getElementById('close-explanation-btn');
        const explanationBackdrop = document.getElementById('explanation-backdrop');
        const similarSentenceBtn = document.getElementById('similar-sentence-btn');
        const analyzeMistakeBtn = document.getElementById('analyze-mistake-btn');

        const modeToggle = document.getElementById('mode-toggle');
        const modeLabelAi = document.getElementById('mode-label-ai');
        const modeLabelPast = document.getElementById('mode-label-past');
        const questionSource = document.getElementById('question-source');

        const pastPaperCache = [
            {
                "source": "'23í•™ë…„ë„ 9ì›” ëª¨ì˜í‰ê°€ 33ë²ˆ'",
                "full": "Problem-framing amounts to defining what problem you are proposing to solve.",
                "blocks": [{"text": "Problem-framing", "type": "subject", "core": true}, {"text": "amounts to", "type": "verb", "core": true}, {"text": "defining", "type": "object", "core": true}, {"text": "what problem you are proposing to solve", "type": "modifier", "core": false}],
                "correctFeedback": "ì •í™•í•´! ë™ëª…ì‚¬ ëª©ì ì–´ê¹Œì§€ ì™„ë²½í•˜ê²Œ ë°œê³¨í–ˆêµ°. ì´ê²Œ ê¸°ë³¸ê¸°ì•¼!",
                "explanation": "'amount to'ëŠ” '~ì™€ ë§ˆì°¬ê°€ì§€ë‹¤'ë¼ëŠ” ëœ»ì˜ ë™ì‚¬êµ¬ì•¼. ê·¸ ë’¤ì— ë™ëª…ì‚¬ 'defining'ì´ ëª©ì ì–´ë¡œ ì™”ì§€. ê·¸ë¦¬ê³  ê·¸ 'defining'ì˜ ëª©ì ì–´ë¡œ 'what'ì´ ì´ë„ëŠ” ëª…ì‚¬ì ˆì´ ì˜¨, ì‚´ì§ ë³µì¡í•œ êµ¬ì¡°ì•¼. í•µì‹¬ì€ 'ë¬¸ì œ êµ¬ì„±ì€ ì •ì˜í•˜ëŠ” ê²ƒê³¼ ê°™ë‹¤'ëŠ” ë¼ˆëŒ€ë¥¼ ë³´ëŠ” ê±°ì§€.",
                "takeaway": "ì „ì¹˜ì‚¬ ë’¤ì—ëŠ” ëª…ì‚¬(ë©ì–´ë¦¬)! ë™ëª…ì‚¬ë„ ëª…ì‚¬ë¼ëŠ” ê±¸ ìŠì§€ ë§ˆ."
            },
            {
                "source": "'22í•™ë…„ë„ ìˆ˜ëŠ¥ 21ë²ˆ'",
                "full": "Not only does the artist create a work, but the work in turn creates the artist.",
                "blocks": [{"text": "Not only", "type": "modifier", "core": false}, {"text": "does", "type": "verb", "core": true}, {"text": "the artist", "type": "subject", "core": true}, {"text": "create a work,", "type": "object", "core": true}, {"text": "but the work in turn creates the artist.", "type": "modifier", "core": false}],
                "correctFeedback": "ì´ì—´~ ë¶€ì •ì–´ ë„ì¹˜ êµ¬ë¬¸! ì´ê±¸ í•œ ë²ˆì— ë³´ë‹¤ë‹ˆ, ê°ê°ì´ ë³´í†µì´ ì•„ë‹Œë°?",
                "explanation": "ë¬¸ì¥ ë§¨ ì•ì— 'Not only' ê°™ì€ ë¶€ì •ì–´ê°€ íŠ€ì–´ë‚˜ì˜¤ë©´ ì£¼ì–´ë‘ ë™ì‚¬ ìë¦¬ê°€ ë°”ë€ŒëŠ” 'ë„ì¹˜'ê°€ ì¼ì–´ë‚˜. ì˜ë¬¸ë¬¸ì²˜ëŸ¼ ì¡°ë™ì‚¬(does)ê°€ ë¨¼ì € íŠ€ì–´ë‚˜ì˜¤ê³  ì£¼ì–´(the artist), ë™ì‚¬ì›í˜•(create) ìˆœì„œê°€ ëœ ê±° ë³´ì´ì§€? 'Aë¿ë§Œ ì•„ë‹ˆë¼ Bë„'ë¼ëŠ” ëœ»ì¸ë°, ë„ì¹˜ í•¨ì •ë§Œ í”¼í•˜ë©´ ë¼ˆëŒ€ëŠ” ì•„ì£¼ ê°„ë‹¨í•´.",
                "takeaway": "ë¶€ì •ì–´ê°€ ë¬¸ì¥ ëŒ€ê°€ë¦¬ë¡œ? ì£¼ì–´ ë™ì‚¬ í—¤ë“œìŠ¤í•€! (ë„ì¹˜)"
            },
            {
                "source": "'24í•™ë…„ë„ ìˆ˜ëŠ¥ 34ë²ˆ'",
                "full": "What is striking about them is that, seemingly against their own self-interest, they are showing trust.",
                "blocks": [{"text": "What is striking about them", "type": "subject", "core": true}, {"text": "is", "type": "verb", "core": true}, {"text": "that, seemingly against their own self-interest, they are showing trust.", "type": "complement", "core": true}],
                "correctFeedback": "Whatì ˆ ì£¼ì–´ì— thatì ˆ ë³´ì–´ê¹Œì§€! ê°€ì¥ ë³µì¡í•œ ë¼ˆëŒ€ë¥¼ ì •í™•íˆ ë´¤ì–´. ì´ ì •ë„ë©´ í•˜ì‚°í•´ë„ ë˜ê² ëŠ”ë°?",
                "explanation": "ì´ ë¬¸ì¥ì€ 'What'ì´ ì´ë„ëŠ” ëª…ì‚¬ì ˆ('ê·¸ê²ƒë“¤ì— ëŒ€í•´ ë†€ë¼ìš´ ì ì€')ì´ í†µì§¸ë¡œ ì£¼ì–´ì•¼. ê·¸ë¦¬ê³  beë™ì‚¬ ë’¤ì—ëŠ” 'that'ì´ ì´ë„ëŠ” ëª…ì‚¬ì ˆ('ê·¸ë“¤ì´ ì‹ ë¢°ë¥¼ ë³´ì—¬ì£¼ê³  ìˆë‹¤ëŠ” ê²ƒ')ì´ ë³´ì–´ë¡œ ì˜¨ êµ¬ì¡°ì§€. ì¤‘ê°„ì— ë‚€ 'seemingly...'ëŠ” ê±°í’ˆì¼ ë¿! 'AëŠ” Bì´ë‹¤' ë¼ëŠ” í° ë¼ˆëŒ€ë¥¼ ë³´ëŠ” ê²Œ í•µì‹¬ì´ì•¼.",
                "takeaway": "Whatì ˆì€ ë„¤ëª¨ë°•ìŠ¤! ë¬¸ì¥ ì „ì²´ê°€ í•˜ë‚˜ì˜ ì£¼ì–´ê°€ ë  ìˆ˜ ìˆë‹¤!"
            }
        ];
        let pastPaperIndex = 0;
        
        const systemPrompt_Generate = `You are 'ê¹€ëŒ€ìˆœ', a top-tier, charismatic CSAT (Korean SAT) English instructor. Your teaching style is direct, punchy, and uses memorable analogies. You call your students 'ì œì' (disciple). You specialize in breaking down complex sentences to their core components, a process you call 'ë°œê³¨' (deboning). Your tone is cool, modern, and motivating. You MUST provide your response in a valid JSON format, following this exact schema: { "full": "The complete English sentence.", "blocks": [ { "text": "A chunk of the sentence", "type": "subject/verb/object/complement/modifier", "core": true (for core components like S,V,O,C) or false (for modifiers) } ], "correctFeedback": "A short, punchy, and encouraging message in Korean.", "explanation": "A concise but insightful explanation in Korean of the key grammar point.", "takeaway": "A very short, memorable one-liner or mnemonic in Korean for the grammar rule." }`;

        function updateToggleLabels() {
            if (modeToggle.checked) { // ê¸°ì¶œ ë¶„ì„ mode
                modeLabelAi.classList.remove('font-bold', 'text-white');
                modeLabelAi.classList.add('font-semibold', 'text-gray-400');
                modeLabelPast.classList.remove('font-semibold', 'text-gray-400');
                modeLabelPast.classList.add('font-bold', 'text-cyan-400');
            } else { // ëŒ€ìˆœ's ì¶”ì²œ mode
                modeLabelAi.classList.add('font-bold', 'text-white');
                modeLabelAi.classList.remove('font-semibold', 'text-gray-400');
                modeLabelPast.classList.add('font-semibold', 'text-gray-400');
                modeLabelPast.classList.remove('font-bold', 'text-cyan-400');
            }
        }

        async function getNextSentence() {
            const isPastPaperMode = modeToggle.checked;
            
            if (isPastPaperMode) {
                loaderText.innerHTML = `<i class="fa-solid fa-database"></i> ê¸°ì¶œ DBì—ì„œ ë¬¸ì œ ë¡œë”© ì¤‘...`;
                mainContent.classList.add('hidden');
                actionBar.classList.add('hidden');
                closeExplanation();
                loaderContainer.style.display = 'flex';
                feedbackContainer.innerHTML = '';
                
                await new Promise(res => setTimeout(res, 500));
                
                currentSentence = pastPaperCache[pastPaperIndex];
                pastPaperIndex = (pastPaperIndex + 1) % pastPaperCache.length;
                currentSentence.blocks = currentSentence.blocks.map((b, i) => ({ ...b, id: i }));
                setupNewSentence();
                loaderContainer.style.display = 'none';

            } else {
                await fetchSentenceFromAI("Generate a new complex sentence.");
            }
        }

        async function fetchSentenceFromAI(prompt, systemPrompt = systemPrompt_Generate, isAnalysis = false) {
             if (!isAnalysis) {
                loaderText.innerHTML = `<i class="fa-solid fa-robot"></i> ëŒ€ìˆœ's ì¶”ì²œ ë¬¸ì œ ìƒì„± ì¤‘...`;
                mainContent.classList.add('hidden');
                actionBar.classList.add('hidden');
                closeExplanation();
                loaderContainer.style.display = 'flex';
                feedbackContainer.innerHTML = '';
            }
            
            const apiUrl = `https://generativelanguage.googleapis.com/v1beta/models/gemini-2.5-flash-preview-05-20:generateContent?key=${apiKey}`;
            const payload = {
                contents: [{ parts: [{ text: prompt }] }],
                systemInstruction: { parts: [{ text: systemPrompt }] },
                generationConfig: { responseMimeType: isAnalysis ? "text/plain" : "application/json" }
            };

            const maxRetries = 3;
            let delay = 1000;
            let lastError;

            for (let attempt = 1; attempt <= maxRetries; attempt++) {
                try {
                    const response = await fetch(apiUrl, { method: 'POST', headers: { 'Content-Type': 'application/json' }, body: JSON.stringify(payload) });
                    if (!response.ok) { 
                        const errorData = await response.json().catch(() => ({ error: { message: `HTTP Error: ${response.status}` } }));
                        if (response.status === 429 || response.status === 503 || (errorData.error && errorData.error.message.includes("overloaded"))) {
                           throw new Error(`Retryable Error: ${errorData.error.message}`);
                        }
                        throw new Error(`Non-retryable Error: ${errorData.error.message}`);
                     }
                    
                    const result = await response.json();
                    const text = result.candidates[0].content.parts[0].text;
                    
                    if (isAnalysis) {
                        return text;
                    } else {
                        currentSentence = JSON.parse(text);
                        currentSentence.blocks = currentSentence.blocks.map((b, i) => ({ ...b, id: i }));
                        setupNewSentence();
                        loaderContainer.style.display = 'none';
                        return;
                    }
                } catch (error) { 
                    lastError = error;
                    console.error(`Attempt ${attempt} failed: ${error.message}`);
                    if (error.message.startsWith("Non-retryable") || attempt === maxRetries) {
                        break;
                    }
                    await new Promise(res => setTimeout(res, delay));
                    delay *= 2;
                }
            }
             console.error("Error fetching from AI after all retries:", lastError);
             if (!isAnalysis) {
                feedbackContainer.innerHTML = `<p class="text-red-400 font-bold text-center">ì•—! ëŒ€ìˆœì˜ì–´ AI ì—°ê²°ì— ì‹¤íŒ¨í–ˆì–´.<br>ì ì‹œ í›„ ë‹¤ì‹œ ì‹œë„í•´ë´, ì œì!</p>`;
                loaderContainer.style.display = 'none';
             }
             return null;
        }
        
        function createBlockElement(block) {
            const el = document.createElement('div');
            el.dataset.id = block.id;
            el.dataset.type = block.type;
            el.dataset.core = block.core;
            el.draggable = true;
            el.innerHTML = `<span>${block.text}</span> <i class="fa-solid fa-volume-high text-gray-400/50 hover:text-white transition-colors cursor-pointer text-sm absolute top-2 right-2 speaker-icon"></i>`;
            const initialColor = 'bg-gray-700/50 border-gray-600 text-gray-200';
            el.className = `sentence-block p-3 pr-8 rounded-lg font-semibold shadow-md glass relative ${initialColor}`;
            return el;
        }

        function setupNewSentence() {
            if (!currentSentence) return;
            mainContent.classList.remove('hidden');
            actionBar.classList.remove('hidden');
            
            questionSource.textContent = currentSentence.source || '';

            blockTray.innerHTML = '';
            autopsyTable.innerHTML = '';
            autopsyTable.appendChild(autopsyPlaceholder);
            autopsyPlaceholder.style.opacity = 1;
            feedbackContainer.innerHTML = '';
            checkBtn.disabled = false;
            lastIncorrectAnswer = null;

            const shuffledBlocks = [...currentSentence.blocks].sort(() => Math.random() - 0.5);
            shuffledBlocks.forEach(block => blockTray.appendChild(createBlockElement(block)));
            addDragListeners();
        }
        
        function addDragListeners() {
            const blocks = document.querySelectorAll('.sentence-block');
            blocks.forEach(block => {
                // Mouse Events
                block.addEventListener('dragstart', handleDragStart);
                block.addEventListener('dragend', handleDragEnd);

                // Touch Events
                block.addEventListener('touchstart', handleTouchStart, { passive: false });
                block.addEventListener('touchmove', handleTouchMove, { passive: false });
                block.addEventListener('touchend', handleTouchEnd);
            });

            [blockTray, autopsyTable].forEach(container => {
                // Mouse Events
                container.addEventListener('dragover', e => e.preventDefault());
                container.addEventListener('drop', handleDrop);
            });
        }
        
        // --- Drag and Drop Handlers ---
        function handleDragStart(e) {
            draggedBlock = e.target;
            setTimeout(() => e.target.classList.add('dragging'), 0);
        }

        function handleDragEnd(e) {
            if (draggedBlock) {
                draggedBlock.classList.remove('dragging');
            }
            draggedBlock = null;
        }

        function handleDrop(e) {
            e.preventDefault();
            const dropZone = e.target.closest('.block-tray, .autopsy-table');
            if (dropZone && draggedBlock) {
                dropZone.appendChild(draggedBlock);
                autopsyPlaceholder.style.opacity = (autopsyTable.querySelectorAll('.sentence-block').length === 0) ? 1 : 0;
            }
        }
        
        // --- Touch Handlers ---
        let touchStartX = 0;
        let touchStartY = 0;

        function handleTouchStart(e) {
            e.preventDefault();
            draggedBlock = e.target.closest('.sentence-block');
            draggedBlock.classList.add('dragging');
            const touch = e.touches[0];
            touchStartX = touch.clientX;
            touchStartY = touch.clientY;
        }

        function handleTouchMove(e) {
            if (!draggedBlock) return;
            e.preventDefault();
            const touch = e.touches[0];
            const x = touch.clientX;
            const y = touch.clientY;
            draggedBlock.style.transform = `translate(${x - touchStartX}px, ${y - touchStartY}px)`;
        }

        function handleTouchEnd(e) {
            if (!draggedBlock) return;
            
            draggedBlock.style.transform = '';
            draggedBlock.classList.remove('dragging');

            const touch = e.changedTouches[0];
            const dropTarget = document.elementFromPoint(touch.clientX, touch.clientY);
            const dropZone = dropTarget ? dropTarget.closest('.block-tray, .autopsy-table') : null;
            
            if (dropZone) {
                dropZone.appendChild(draggedBlock);
            } else {
                 blockTray.appendChild(draggedBlock); // Return to tray if dropped outside
            }
            autopsyPlaceholder.style.opacity = (autopsyTable.querySelectorAll('.sentence-block').length === 0) ? 1 : 0;
            draggedBlock = null;
        }


        function checkAnswer() {
            const placedBlocks = Array.from(autopsyTable.querySelectorAll('.sentence-block'));
            const isAnswerCorrect = (() => {
                if (!placedBlocks.length) return false;
                const coreBlocksInTable = placedBlocks.every(b => b.dataset.core === 'true');
                if (!coreBlocksInTable) return false;
                const allCoreBlocks = currentSentence.blocks.filter(b => b.core);
                const placedIds = placedBlocks.map(b => parseInt(b.dataset.id));
                const correctCoreIds = allCoreBlocks.map(b => b.id);
                if (placedIds.length !== correctCoreIds.length) return false;
                return placedIds.every((id, i) => id === correctCoreIds[i]);
            })();

            if (!isAnswerCorrect) {
                 lastIncorrectAnswer = placedBlocks.map(b => b.querySelector('span').textContent).join(' / ');
            }

            updateStreak(isAnswerCorrect);
            updateXp(isAnswerCorrect);
            displayFeedback(isAnswerCorrect);
            revealBlockColors();
            checkBtn.disabled = true;
        }
        
        function updateStreak(isCorrect) {
            streak = isCorrect ? streak + 1 : 0;
            streakCountEl.textContent = streak;
            const streakEl = streakCountEl.parentElement;
            if (isCorrect && streak > 0) {
                streakEl.classList.add('animate-bounce');
                setTimeout(() => streakEl.classList.remove('animate-bounce'), 1000);
            }
        }
        
        function updateXp(isCorrect) {
            if (isCorrect) {
                const xpGained = 10 + (streak * 2); 
                xp += xpGained;
                if (xp >= xpPerLevel) {
                    xp = xp % xpPerLevel;
                    level++;
                    levelEl.textContent = level;
                    const levelIndicator = document.getElementById('level-indicator');
                    levelIndicator.classList.add('animate-pulse', 'scale-125');
                    setTimeout(()=> levelIndicator.classList.remove('animate-pulse', 'scale-125'), 1000);
                }
            }
            const xpPercentage = (xp / xpPerLevel) * 100;
            xpBarFill.style.width = `${xpPercentage}%`;
        }

        function revealBlockColors() {
             document.querySelectorAll('.sentence-block').forEach(el => {
                const blockData = currentSentence.blocks.find(b => b.id == el.dataset.id);
                if (!blockData) return;
                
                el.className = 'sentence-block p-3 pr-8 rounded-lg font-semibold shadow-md glass relative '; 
                let colorClasses = 'bg-gray-700/50 border-gray-600 text-gray-200';
                if (blockData.core) {
                    switch (blockData.type) {
                        case 'subject': colorClasses += ' bg-blue-500/50 border-blue-400 text-white neon-blue'; break;
                        case 'verb': colorClasses += ' bg-red-500/50 border-red-400 text-white neon-red'; break;
                        default: colorClasses += ' bg-green-500/50 border-green-400 text-white neon-green'; break;
                    }
                }
                el.classList.add(...colorClasses.split(' '));
             });
        }

        function displayFeedback(isCorrect) {
            feedbackContainer.innerHTML = '';
            const feedbackEl = document.createElement('div');
            feedbackEl.className = 'flex items-center justify-center gap-2 text-center font-bold text-lg';
            
            if (isCorrect) {
                feedbackEl.innerHTML = `<i class="fa-solid fa-circle-check text-2xl"></i> <span>${currentSentence.correctFeedback}</span>`;
                feedbackEl.classList.add('text-green-400', 'feedback-correct');
                analyzeMistakeBtn.classList.add('hidden');
            } else {
                const incorrectMessages = [ "ì–´ì´ì¿ ! ë¼ˆëŒ€ë§Œ ë°œë¼ë‚´ì•¼ì§€!", "ìˆœì„œê°€ í‹€ë ¸ì–ì•„? ë‹¤ì‹œ!", "í•µì‹¬ ë¼ˆëŒ€ê°€ ë¹ ì¡ŒëŠ”ë°?" ];
                feedbackEl.innerHTML = `<i class="fa-solid fa-circle-xmark text-2xl"></i> <span>${incorrectMessages[Math.floor(Math.random() * incorrectMessages.length)]}</span>`;
                feedbackEl.classList.add('text-red-400', 'feedback-incorrect');
                analyzeMistakeBtn.classList.remove('hidden');
                analyzeMistakeBtn.disabled = false;
            }
            feedbackContainer.appendChild(feedbackEl);
            
            explanationTitle.innerHTML = `<i class="fa-solid fa-pen-to-square"></i> ëŒ€ìˆœ's Point! ì§šê³  ê°€ê¸°!`;
            explanationText.textContent = currentSentence.explanation;
            takeawayText.textContent = currentSentence.takeaway || '';
            takeawayContainer.style.display = currentSentence.takeaway ? 'block' : 'none';
            explanationSheet.classList.remove('hidden');
        }

        async function analyzeMistake() {
            if (!lastIncorrectAnswer) return;
            
            const btnOriginalText = analyzeMistakeBtn.innerHTML;
            analyzeMistakeBtn.innerHTML = `<i class="fa-solid fa-spinner animate-spin"></i> ë¶„ì„ ì¤‘...`;
            analyzeMistakeBtn.disabled = true;

            try {
                const correctCore = currentSentence.blocks.filter(b => b.core).map(b => b.text).join(' / ');
                const systemPrompt = `You are 'ê¹€ëŒ€ìˆœ', a top-tier CSAT English instructor. A student tried to find the core components of the sentence "${currentSentence.full}". The correct core components are "${correctCore}". The student's incorrect answer was "${lastIncorrectAnswer}". In your punchy, direct persona, explain concisely in Korean WHY the student's answer is wrong. Point out their specific misunderstanding. Do not provide the full correct answer, just focus on the mistake.`;
                
                const analysis = await fetchSentenceFromAI("Analyze my mistake.", systemPrompt, true);
                
                if (analysis) {
                    explanationTitle.innerHTML = `<i class="fa-solid fa-magnifying-glass-chart"></i> ë„ˆì˜ ì˜¤ë‹µ, ì •ë°€ ë¶„ì„!`;
                    explanationText.textContent = analysis;
                    takeawayContainer.style.display = 'none';
                } else {
                    explanationText.textContent = "ì˜¤ë‹µ ë¶„ì„ì— ì‹¤íŒ¨í–ˆì–´. ì ì‹œ í›„ ë‹¤ì‹œ ì‹œë„í•´ë´.";
                }
            } finally {
                 analyzeMistakeBtn.innerHTML = btnOriginalText;
                 analyzeMistakeBtn.disabled = false;
            }
        }

        function closeExplanation() { explanationSheet.classList.add('hidden'); }
        
        function base64ToArrayBuffer(base64) {
            const binaryString = window.atob(base64);
            const len = binaryString.length;
            const bytes = new Uint8Array(len);
            for (let i = 0; i < len; i++) { bytes[i] = binaryString.charCodeAt(i); }
            return bytes.buffer;
        }
        function pcmToWav(pcmData, sampleRate) { 
            const numChannels = 1, bytesPerSample = 2, blockAlign = numChannels * bytesPerSample;
            const byteRate = sampleRate * blockAlign, dataSize = pcmData.length * bytesPerSample;
            const buffer = new ArrayBuffer(44 + dataSize);
            const view = new DataView(buffer);
            view.setUint32(0, 0x52494646, false); 
            view.setUint32(4, 36 + dataSize, true); view.setUint32(8, 0x57415645, false); 
            view.setUint32(12, 0x666d7420, false); 
            view.setUint32(16, 16, true); view.setUint16(20, 1, true); view.setUint16(22, numChannels, true);
            view.setUint32(24, sampleRate, true); view.setUint32(28, byteRate, true);
            view.setUint16(32, blockAlign, true); view.setUint16(34, bytesPerSample * 8, true);
            view.setUint32(36, 0x64617461, false); 
            view.setUint32(40, dataSize, true);
            for (let i = 0; i < pcmData.length; i++) { view.setInt16(44 + i * 2, pcmData[i], true); }
            return new Blob([view], { type: 'audio/wav' });
        }
        
        async function playAudio(text, iconElement) {
            if (iconElement.classList.contains('fa-spinner')) return; 
            const originalIcon = iconElement.className;
            iconElement.className = 'fa-solid fa-spinner animate-spin text-cyan-400 speaker-icon';

            const maxRetries = 3;
            let delay = 1000;

            for (let attempt = 1; attempt <= maxRetries; attempt++) {
                try {
                    const ttsApiUrl = `https://generativelanguage.googleapis.com/v1beta/models/gemini-2.5-flash-preview-tts:generateContent?key=${apiKey}`;
                    const payload = {
                        contents: [{ parts: [{ text }] }],
                        generationConfig: { responseModalities: ["AUDIO"] },
                        model: "gemini-2.5-flash-preview-tts"
                    };
                    const response = await fetch(ttsApiUrl, { method: 'POST', headers: { 'Content-Type': 'application/json' }, body: JSON.stringify(payload) });
                    
                    if (!response.ok) {
                        const errorData = await response.json().catch(() => ({ error: { message: `HTTP Error: ${response.status}` } }));
                        if (response.status === 429 || response.status === 503 || (errorData.error && errorData.error.message.includes("overloaded"))) {
                           throw new Error(`Retryable Error: ${errorData.error.message}`);
                        }
                        throw new Error(`Non-retryable Error: ${errorData.error.message}`);
                    }

                    const result = await response.json();
                    const audioData = result?.candidates?.[0]?.content?.parts?.[0]?.inlineData?.data;
                    const mimeType = result?.candidates?.[0]?.content?.parts?.[0]?.inlineData?.mimeType;

                    if (audioData && mimeType && mimeType.startsWith("audio/")) {
                        const sampleRate = parseInt(mimeType.match(/rate=(\d+)/)[1], 10);
                        const pcmBuffer = base64ToArrayBuffer(audioData);
                        const pcm16 = new Int16Array(pcmBuffer);
                        const wavBlob = pcmToWav(pcm16, sampleRate);
                        const audioUrl = URL.createObjectURL(wavBlob);
                        new Audio(audioUrl).play();
                        iconElement.className = originalIcon;
                        return;
                    } else {
                        throw new Error('Invalid audio data received');
                    }
                } catch (error) {
                    console.error(`TTS Attempt ${attempt} failed:`, error);
                    if (error.message.startsWith("Non-retryable") || attempt === maxRetries) {
                        console.error("Error playing audio: Could not recover after retries.", error);
                        iconElement.className = originalIcon;
                        break;
                    }
                    await new Promise(res => setTimeout(res, delay));
                    delay *= 2;
                }
            }
        }

        checkBtn.addEventListener('click', checkAnswer);
        nextBtn.addEventListener('click', getNextSentence);
        modeToggle.addEventListener('change', () => {
            updateToggleLabels();
            getNextSentence();
        });
        closeExplanationBtn.addEventListener('click', closeExplanation);
        explanationBackdrop.addEventListener('click', closeExplanation);
        analyzeMistakeBtn.addEventListener('click', analyzeMistake);
        
        similarSentenceBtn.addEventListener('click', () => {
             const prompt = `The previous grammar point was about: "${currentSentence.explanation}". Generate a NEW sentence that tests the same grammar concept but uses different vocabulary. It must not be from a past paper and you must not include the 'source' field in the JSON.`;
             fetchSentenceFromAI(prompt);
        });
        
        mainContent.addEventListener('click', e => {
            if (e.target.classList.contains('speaker-icon')) {
                const text = e.target.closest('.sentence-block').querySelector('span').textContent;
                playAudio(text, e.target);
            }
        });

        document.addEventListener('DOMContentLoaded', () => {
            updateToggleLabels();
            getNextSentence();
        });
    </script>
</body>
</html>

