<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    
    <!-- 홈 화면 앱 모드 설정 (주소창 숨기기) -->
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
    <meta name="apple-mobile-web-app-title" content="대순영어">

    <title>대순영어 (AI Ver.)</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.5.1/css/all.min.css">
    <link href="https://fonts.googleapis.com/css2?family=Noto+Sans+KR:wght@400;500;700;900&display=swap" rel="stylesheet">
    <style>
        html, body {
            height: 100%;
            overflow: hidden;
        }
        body {
            font-family: 'Noto Sans KR', sans-serif;
            touch-action: manipulation;
            background: #0F0C29;
            background: -webkit-linear-gradient(to right, #24243E, #302B63, #0F0C29);
            background: linear-gradient(to right, #24243E, #302B63, #0F0C29);
        }
        .glass {
            background: rgba(255, 255, 255, 0.05);
            backdrop-filter: blur(12px);
            -webkit-backdrop-filter: blur(12px);
            border: 1px solid rgba(255, 255, 255, 0.1);
        }
        .sentence-block {
            cursor: grab;
            transition: all 0.2s ease-in-out;
            touch-action: none; /* 터치 이벤트 직접 제어 */
        }
        .sentence-block:active {
            cursor: grabbing;
        }
        .dragging { 
            opacity: 0.5; 
            transform: scale(1.05);
            z-index: 1000;
            box-shadow: 0 0 25px rgba(124, 58, 237, 0.6);
        }
        
        .neon-blue { box-shadow: 0 0 5px #60a5fa, 0 0 10px #60a5fa; }
        .neon-red { box-shadow: 0 0 5px #f87171, 0 0 10px #f87171; }
        .neon-green { box-shadow: 0 0 5px #4ade80, 0 0 10px #4ade80; }

        @keyframes popIn { 0% { transform: scale(0.8); opacity: 0; } 100% { transform: scale(1); opacity: 1; } }
        @keyframes shake { 0%, 100% { transform: translateX(0); } 10%, 30%, 50%, 70%, 90% { transform: translateX(-8px); } 20%, 40%, 60%, 80% { transform: translateX(8px); } }
        .feedback-correct { animation: popIn 0.5s ease; }
        .feedback-incorrect { animation: shake 0.5s ease; }
        @keyframes slideUp { from { transform: translateY(100%); opacity: 0; } to { transform: translateY(0); opacity: 1; } }
        .bottom-sheet { animation: slideUp 0.5s cubic-bezier(0.25, 0.46, 0.45, 0.94); }
        .loader { border: 4px solid #4a5568; border-top: 4px solid #a78bfa; border-radius: 50%; width: 50px; height: 50px; animation: spin 1s linear infinite; }
        @keyframes spin { 0% { transform: rotate(0deg); } 100% { transform: rotate(360deg); } }
        
        #xp-bar-fill { transition: width 0.5s ease-in-out; }
        .autopsy-placeholder { transition: opacity 0.3s ease; }
        .speaker-icon {
            transition: color 0.2s ease-in-out;
        }
        /* Toggle Switch */
        .toggle-checkbox:checked + .toggle-label {
            background-color: #4f46e5; /* indigo-600 */
        }
        .toggle-checkbox:checked + .toggle-label .toggle-ball {
            transform: translateX(100%);
        }
        .mode-label {
            transition: all 0.3s ease;
        }
    </style>
</head>
<body class="text-gray-200 flex flex-col h-screen">

    <header class="text-center pt-5 pb-3 px-4 flex-shrink-0">
        <div class="flex justify-between items-center w-full max-w-3xl mx-auto">
            <div id="level-indicator" class="text-lg font-bold bg-violet-500 text-white rounded-full px-4 py-1.5 flex items-center gap-2">
                <i class="fa-solid fa-star"></i>
                <span>Lv. <span id="level">1</span></span>
            </div>
            <h1 class="text-2xl font-black text-white tracking-tighter">대순영어</h1>
            <div id="streak-counter" class="text-lg font-bold bg-amber-500 text-gray-900 rounded-full px-4 py-1.5 flex items-center gap-2">
                <i class="fa-solid fa-fire"></i>
                <span id="streak-count">0</span>
            </div>
        </div>
        <div id="xp-bar" class="w-full max-w-3xl mx-auto mt-3 h-2.5 bg-gray-700 rounded-full">
            <div id="xp-bar-fill" class="h-2.5 bg-gradient-to-r from-violet-500 to-fuchsia-500 rounded-full" style="width: 0%"></div>
        </div>
    </header>

    <main class="flex-grow flex flex-col justify-center px-4 overflow-y-auto">
        <div class="w-full max-w-3xl mx-auto mb-4 flex justify-center items-center gap-3">
             <span id="mode-label-ai" class="mode-label">대순's 추천</span>
             <label for="mode-toggle" class="flex items-center cursor-pointer">
                <div class="relative">
                    <input type="checkbox" id="mode-toggle" class="sr-only toggle-checkbox">
                    <div class="toggle-label block bg-gray-600 w-14 h-8 rounded-full"></div>
                    <div class="toggle-ball absolute left-1 top-1 bg-white w-6 h-6 rounded-full transition-transform"></div>
                </div>
            </label>
            <span id="mode-label-past" class="mode-label">🔥 기출 분석</span>
        </div>
        
        <div id="loader-container" class="my-8 flex justify-center items-center flex-col">
            <div class="loader"></div>
            <p id="loader-text" class="mt-4 text-violet-400 font-semibold text-lg flex items-center gap-2"></p>
        </div>
        
        <div id="main-content" class="hidden w-full max-w-3xl mx-auto">
            <div id="question-source" class="text-center font-bold text-cyan-400 mb-4 h-6"></div>
            <div class="my-6">
                <h2 class="font-bold text-gray-400 mb-3 text-center text-lg flex items-center justify-center gap-2"><i class="fa-solid fa-puzzle-piece"></i> 문장 재료들: 여기서 뼈대를 발골해봐!</h2>
                <div id="block-tray" class="block-tray p-4 rounded-xl border-2 border-gray-700 flex flex-wrap gap-3 justify-center items-center glass"></div>
            </div>

            <div class="mb-6">
                <h2 class="font-bold text-gray-400 mb-3 text-center text-lg flex items-center justify-center gap-2"><i class="fa-solid fa-microscope"></i> 해부실: <span class="text-red-400">'뼈대'</span>만 올려봐!</h2>
                <div id="autopsy-table" class="autopsy-table p-4 rounded-xl border-2 border-violet-700 flex flex-wrap gap-3 justify-center items-center glass relative">
                    <div id="autopsy-placeholder" class="autopsy-placeholder absolute inset-0 flex flex-col items-center justify-center text-gray-600 pointer-events-none">
                        <i class="fa-solid fa-hand-pointer text-4xl mb-2"></i>
                        <span class="font-semibold">이곳으로 뼈대를 옮겨봐!</span>
                    </div>
                </div>
            </div>
            
            <div id="feedback-container" class="mt-4 h-12 flex items-center justify-center"></div>
        </div>
    </main>
    
    <footer id="action-bar" class="flex-shrink-0 p-4 w-full max-w-3xl mx-auto hidden">
         <div class="flex gap-3">
            <button id="check-btn" class="w-full bg-gradient-to-r from-violet-600 to-indigo-600 hover:from-violet-700 hover:to-indigo-700 text-white font-bold py-3.5 px-4 rounded-xl text-lg shadow-lg transform transition-transform hover:scale-105 disabled:opacity-50 disabled:cursor-not-allowed">
                <i class="fa-solid fa-check"></i> 뼈대 확인!
            </button>
            <button id="next-btn" class="w-full bg-gray-700 hover:bg-gray-600 text-white font-bold py-3.5 px-4 rounded-xl text-lg shadow-lg transform transition-transform hover:scale-105">
                <i class="fa-solid fa-arrow-right"></i> 다음 문제
            </button>
        </div>
    </footer>

    <div id="explanation-sheet" class="hidden fixed inset-0 z-10">
        <div class="absolute inset-0 bg-black/70" id="explanation-backdrop"></div>
        <div id="explanation-content" class="bottom-sheet absolute bottom-0 left-0 right-0 glass rounded-t-2xl p-6 w-full max-w-3xl mx-auto">
            <h3 id="explanation-title" class="font-black text-2xl bg-clip-text text-transparent bg-gradient-to-r from-amber-400 to-orange-500 mb-3 text-center flex items-center justify-center gap-2"><i class="fa-solid fa-pen-to-square"></i> 대순's Point! 짚고 가기!</h3>
            <div class="bg-gray-900/50 text-gray-300 p-4 rounded-lg">
                <p id="explanation-text" class="text-lg leading-relaxed"></p>
                <div id="takeaway-container" class="mt-4 pt-4 border-t border-gray-700">
                    <h4 class="font-bold text-amber-400 flex items-center gap-2"><i class="fa-solid fa-key"></i>이것만 기억해!</h4>
                    <p id="takeaway-text" class="italic"></p>
                </div>
            </div>
            <div class="mt-4 flex flex-col sm:flex-row gap-3">
                <button id="similar-sentence-btn" class="w-full bg-gradient-to-r from-teal-500 to-cyan-500 hover:from-teal-600 hover:to-cyan-600 text-white font-bold py-3 px-4 rounded-xl text-lg shadow-lg transform transition-transform hover:scale-105">
                    <i class="fa-solid fa-wand-magic-sparkles"></i> 이 문법으로 더 훈련하기
                </button>
                 <button id="analyze-mistake-btn" class="w-full bg-gradient-to-r from-rose-500 to-pink-500 hover:from-rose-600 hover:to-pink-600 text-white font-bold py-3 px-4 rounded-xl text-lg shadow-lg transform transition-transform hover:scale-105 hidden">
                    <i class="fa-solid fa-magnifying-glass-chart"></i> 내 답안 분석 요청
                </button>
            </div>
            <button id="close-explanation-btn" class="absolute top-4 right-4 text-gray-500 hover:text-white text-2xl">
                <i class="fa-solid fa-xmark"></i>
            </button>
        </div>
    </div>

    <script>
        let currentSentence;
        let lastIncorrectAnswer = null;
        let draggedBlock = null;
        let streak = 0;
        let level = 1;
        let xp = 0;
        const xpPerLevel = 100;

        const apiKey = "AIzaSyBbEsfDqt5ojPAJoo70Nozro4LacKk__4k";

        const mainContent = document.getElementById('main-content');
        const loaderContainer = document.getElementById('loader-container');
        const loaderText = document.getElementById('loader-text');
        const actionBar = document.getElementById('action-bar');
        const blockTray = document.getElementById('block-tray');
        const autopsyTable = document.getElementById('autopsy-table');
        const autopsyPlaceholder = document.getElementById('autopsy-placeholder');
        const checkBtn = document.getElementById('check-btn');
        const nextBtn = document.getElementById('next-btn');
        const feedbackContainer = document.getElementById('feedback-container');
        
        const streakCountEl = document.getElementById('streak-count');
        const levelEl = document.getElementById('level');
        const xpBarFill = document.getElementById('xp-bar-fill');

        const explanationSheet = document.getElementById('explanation-sheet');
        const explanationTitle = document.getElementById('explanation-title');
        const explanationText = document.getElementById('explanation-text');
        const takeawayContainer = document.getElementById('takeaway-container');
        const takeawayText = document.getElementById('takeaway-text');
        const closeExplanationBtn = document.getElementById('close-explanation-btn');
        const explanationBackdrop = document.getElementById('explanation-backdrop');
        const similarSentenceBtn = document.getElementById('similar-sentence-btn');
        const analyzeMistakeBtn = document.getElementById('analyze-mistake-btn');

        const modeToggle = document.getElementById('mode-toggle');
        const modeLabelAi = document.getElementById('mode-label-ai');
        const modeLabelPast = document.getElementById('mode-label-past');
        const questionSource = document.getElementById('question-source');

        const pastPaperCache = [
            {
                "source": "'23학년도 9월 모의평가 33번'",
                "full": "Problem-framing amounts to defining what problem you are proposing to solve.",
                "blocks": [{"text": "Problem-framing", "type": "subject", "core": true}, {"text": "amounts to", "type": "verb", "core": true}, {"text": "defining", "type": "object", "core": true}, {"text": "what problem you are proposing to solve", "type": "modifier", "core": false}],
                "correctFeedback": "정확해! 동명사 목적어까지 완벽하게 발골했군. 이게 기본기야!",
                "explanation": "'amount to'는 '~와 마찬가지다'라는 뜻의 동사구야. 그 뒤에 동명사 'defining'이 목적어로 왔지. 그리고 그 'defining'의 목적어로 'what'이 이끄는 명사절이 온, 살짝 복잡한 구조야. 핵심은 '문제 구성은 정의하는 것과 같다'는 뼈대를 보는 거지.",
                "takeaway": "전치사 뒤에는 명사(덩어리)! 동명사도 명사라는 걸 잊지 마."
            },
            {
                "source": "'22학년도 수능 21번'",
                "full": "Not only does the artist create a work, but the work in turn creates the artist.",
                "blocks": [{"text": "Not only", "type": "modifier", "core": false}, {"text": "does", "type": "verb", "core": true}, {"text": "the artist", "type": "subject", "core": true}, {"text": "create a work,", "type": "object", "core": true}, {"text": "but the work in turn creates the artist.", "type": "modifier", "core": false}],
                "correctFeedback": "이열~ 부정어 도치 구문! 이걸 한 번에 보다니, 감각이 보통이 아닌데?",
                "explanation": "문장 맨 앞에 'Not only' 같은 부정어가 튀어나오면 주어랑 동사 자리가 바뀌는 '도치'가 일어나. 의문문처럼 조동사(does)가 먼저 튀어나오고 주어(the artist), 동사원형(create) 순서가 된 거 보이지? 'A뿐만 아니라 B도'라는 뜻인데, 도치 함정만 피하면 뼈대는 아주 간단해.",
                "takeaway": "부정어가 문장 대가리로? 주어 동사 헤드스핀! (도치)"
            },
            {
                "source": "'24학년도 수능 34번'",
                "full": "What is striking about them is that, seemingly against their own self-interest, they are showing trust.",
                "blocks": [{"text": "What is striking about them", "type": "subject", "core": true}, {"text": "is", "type": "verb", "core": true}, {"text": "that, seemingly against their own self-interest, they are showing trust.", "type": "complement", "core": true}],
                "correctFeedback": "What절 주어에 that절 보어까지! 가장 복잡한 뼈대를 정확히 봤어. 이 정도면 하산해도 되겠는데?",
                "explanation": "이 문장은 'What'이 이끄는 명사절('그것들에 대해 놀라운 점은')이 통째로 주어야. 그리고 be동사 뒤에는 'that'이 이끄는 명사절('그들이 신뢰를 보여주고 있다는 것')이 보어로 온 구조지. 중간에 낀 'seemingly...'는 거품일 뿐! 'A는 B이다' 라는 큰 뼈대를 보는 게 핵심이야.",
                "takeaway": "What절은 네모박스! 문장 전체가 하나의 주어가 될 수 있다!"
            }
        ];
        let pastPaperIndex = 0;
        
        const systemPrompt_Generate = `You are '김대순', a top-tier, charismatic CSAT (Korean SAT) English instructor. Your teaching style is direct, punchy, and uses memorable analogies. You call your students '제자' (disciple). You specialize in breaking down complex sentences to their core components, a process you call '발골' (deboning). Your tone is cool, modern, and motivating. You MUST provide your response in a valid JSON format, following this exact schema: { "full": "The complete English sentence.", "blocks": [ { "text": "A chunk of the sentence", "type": "subject/verb/object/complement/modifier", "core": true (for core components like S,V,O,C) or false (for modifiers) } ], "correctFeedback": "A short, punchy, and encouraging message in Korean.", "explanation": "A concise but insightful explanation in Korean of the key grammar point.", "takeaway": "A very short, memorable one-liner or mnemonic in Korean for the grammar rule." }`;

        function updateToggleLabels() {
            if (modeToggle.checked) { // 기출 분석 mode
                modeLabelAi.classList.remove('font-bold', 'text-white');
                modeLabelAi.classList.add('font-semibold', 'text-gray-400');
                modeLabelPast.classList.remove('font-semibold', 'text-gray-400');
                modeLabelPast.classList.add('font-bold', 'text-cyan-400');
            } else { // 대순's 추천 mode
                modeLabelAi.classList.add('font-bold', 'text-white');
                modeLabelAi.classList.remove('font-semibold', 'text-gray-400');
                modeLabelPast.classList.add('font-semibold', 'text-gray-400');
                modeLabelPast.classList.remove('font-bold', 'text-cyan-400');
            }
        }

        async function getNextSentence() {
            const isPastPaperMode = modeToggle.checked;
            
            if (isPastPaperMode) {
                loaderText.innerHTML = `<i class="fa-solid fa-database"></i> 기출 DB에서 문제 로딩 중...`;
                mainContent.classList.add('hidden');
                actionBar.classList.add('hidden');
                closeExplanation();
                loaderContainer.style.display = 'flex';
                feedbackContainer.innerHTML = '';
                
                await new Promise(res => setTimeout(res, 500));
                
                currentSentence = pastPaperCache[pastPaperIndex];
                pastPaperIndex = (pastPaperIndex + 1) % pastPaperCache.length;
                currentSentence.blocks = currentSentence.blocks.map((b, i) => ({ ...b, id: i }));
                setupNewSentence();
                loaderContainer.style.display = 'none';

            } else {
                await fetchSentenceFromAI("Generate a new complex sentence.");
            }
        }

        async function fetchSentenceFromAI(prompt, systemPrompt = systemPrompt_Generate, isAnalysis = false) {
             if (!isAnalysis) {
                loaderText.innerHTML = `<i class="fa-solid fa-robot"></i> 대순's 추천 문제 생성 중...`;
                mainContent.classList.add('hidden');
                actionBar.classList.add('hidden');
                closeExplanation();
                loaderContainer.style.display = 'flex';
                feedbackContainer.innerHTML = '';
            }
            
            const apiUrl = `https://generativelanguage.googleapis.com/v1beta/models/gemini-2.5-flash-preview-05-20:generateContent?key=${apiKey}`;
            const payload = {
                contents: [{ parts: [{ text: prompt }] }],
                systemInstruction: { parts: [{ text: systemPrompt }] },
                generationConfig: { responseMimeType: isAnalysis ? "text/plain" : "application/json" }
            };

            const maxRetries = 3;
            let delay = 1000;
            let lastError;

            for (let attempt = 1; attempt <= maxRetries; attempt++) {
                try {
                    const response = await fetch(apiUrl, { method: 'POST', headers: { 'Content-Type': 'application/json' }, body: JSON.stringify(payload) });
                    if (!response.ok) { 
                        const errorData = await response.json().catch(() => ({ error: { message: `HTTP Error: ${response.status}` } }));
                        if (response.status === 429 || response.status === 503 || (errorData.error && errorData.error.message.includes("overloaded"))) {
                           throw new Error(`Retryable Error: ${errorData.error.message}`);
                        }
                        throw new Error(`Non-retryable Error: ${errorData.error.message}`);
                     }
                    
                    const result = await response.json();
                    const text = result.candidates[0].content.parts[0].text;
                    
                    if (isAnalysis) {
                        return text;
                    } else {
                        currentSentence = JSON.parse(text);
                        currentSentence.blocks = currentSentence.blocks.map((b, i) => ({ ...b, id: i }));
                        setupNewSentence();
                        loaderContainer.style.display = 'none';
                        return;
                    }
                } catch (error) { 
                    lastError = error;
                    console.error(`Attempt ${attempt} failed: ${error.message}`);
                    if (error.message.startsWith("Non-retryable") || attempt === maxRetries) {
                        break;
                    }
                    await new Promise(res => setTimeout(res, delay));
                    delay *= 2;
                }
            }
             console.error("Error fetching from AI after all retries:", lastError);
             if (!isAnalysis) {
                feedbackContainer.innerHTML = `<p class="text-red-400 font-bold text-center">앗! 대순영어 AI 연결에 실패했어.<br>잠시 후 다시 시도해봐, 제자!</p>`;
                loaderContainer.style.display = 'none';
             }
             return null;
        }
        
        function createBlockElement(block) {
            const el = document.createElement('div');
            el.dataset.id = block.id;
            el.dataset.type = block.type;
            el.dataset.core = block.core;
            el.draggable = true;
            el.innerHTML = `<span>${block.text}</span> <i class="fa-solid fa-volume-high text-gray-400/50 hover:text-white transition-colors cursor-pointer text-sm absolute top-2 right-2 speaker-icon"></i>`;
            const initialColor = 'bg-gray-700/50 border-gray-600 text-gray-200';
            el.className = `sentence-block p-3 pr-8 rounded-lg font-semibold shadow-md glass relative ${initialColor}`;
            return el;
        }

        function setupNewSentence() {
            if (!currentSentence) return;
            mainContent.classList.remove('hidden');
            actionBar.classList.remove('hidden');
            
            questionSource.textContent = currentSentence.source || '';

            blockTray.innerHTML = '';
            autopsyTable.innerHTML = '';
            autopsyTable.appendChild(autopsyPlaceholder);
            autopsyPlaceholder.style.opacity = 1;
            feedbackContainer.innerHTML = '';
            checkBtn.disabled = false;
            lastIncorrectAnswer = null;

            const shuffledBlocks = [...currentSentence.blocks].sort(() => Math.random() - 0.5);
            shuffledBlocks.forEach(block => blockTray.appendChild(createBlockElement(block)));
            addDragListeners();
        }
        
        function addDragListeners() {
            const blocks = document.querySelectorAll('.sentence-block');
            blocks.forEach(block => {
                // Mouse Events
                block.addEventListener('dragstart', handleDragStart);
                block.addEventListener('dragend', handleDragEnd);

                // Touch Events
                block.addEventListener('touchstart', handleTouchStart, { passive: false });
                block.addEventListener('touchmove', handleTouchMove, { passive: false });
                block.addEventListener('touchend', handleTouchEnd);
            });

            [blockTray, autopsyTable].forEach(container => {
                // Mouse Events
                container.addEventListener('dragover', e => e.preventDefault());
                container.addEventListener('drop', handleDrop);
            });
        }
        
        // --- Drag and Drop Handlers ---
        function handleDragStart(e) {
            draggedBlock = e.target;
            setTimeout(() => e.target.classList.add('dragging'), 0);
        }

        function handleDragEnd(e) {
            if (draggedBlock) {
                draggedBlock.classList.remove('dragging');
            }
            draggedBlock = null;
        }

        function handleDrop(e) {
            e.preventDefault();
            const dropZone = e.target.closest('.block-tray, .autopsy-table');
            if (dropZone && draggedBlock) {
                dropZone.appendChild(draggedBlock);
                autopsyPlaceholder.style.opacity = (autopsyTable.querySelectorAll('.sentence-block').length === 0) ? 1 : 0;
            }
        }
        
        // --- Touch Handlers ---
        let touchStartX = 0;
        let touchStartY = 0;

        function handleTouchStart(e) {
            e.preventDefault();
            draggedBlock = e.target.closest('.sentence-block');
            draggedBlock.classList.add('dragging');
            const touch = e.touches[0];
            touchStartX = touch.clientX;
            touchStartY = touch.clientY;
        }

        function handleTouchMove(e) {
            if (!draggedBlock) return;
            e.preventDefault();
            const touch = e.touches[0];
            const x = touch.clientX;
            const y = touch.clientY;
            draggedBlock.style.transform = `translate(${x - touchStartX}px, ${y - touchStartY}px)`;
        }

        function handleTouchEnd(e) {
            if (!draggedBlock) return;
            
            draggedBlock.style.transform = '';
            draggedBlock.classList.remove('dragging');

            const touch = e.changedTouches[0];
            const dropTarget = document.elementFromPoint(touch.clientX, touch.clientY);
            const dropZone = dropTarget ? dropTarget.closest('.block-tray, .autopsy-table') : null;
            
            if (dropZone) {
                dropZone.appendChild(draggedBlock);
            } else {
                 blockTray.appendChild(draggedBlock); // Return to tray if dropped outside
            }
            autopsyPlaceholder.style.opacity = (autopsyTable.querySelectorAll('.sentence-block').length === 0) ? 1 : 0;
            draggedBlock = null;
        }


        function checkAnswer() {
            const placedBlocks = Array.from(autopsyTable.querySelectorAll('.sentence-block'));
            const isAnswerCorrect = (() => {
                if (!placedBlocks.length) return false;
                const coreBlocksInTable = placedBlocks.every(b => b.dataset.core === 'true');
                if (!coreBlocksInTable) return false;
                const allCoreBlocks = currentSentence.blocks.filter(b => b.core);
                const placedIds = placedBlocks.map(b => parseInt(b.dataset.id));
                const correctCoreIds = allCoreBlocks.map(b => b.id);
                if (placedIds.length !== correctCoreIds.length) return false;
                return placedIds.every((id, i) => id === correctCoreIds[i]);
            })();

            if (!isAnswerCorrect) {
                 lastIncorrectAnswer = placedBlocks.map(b => b.querySelector('span').textContent).join(' / ');
            }

            updateStreak(isAnswerCorrect);
            updateXp(isAnswerCorrect);
            displayFeedback(isAnswerCorrect);
            revealBlockColors();
            checkBtn.disabled = true;
        }
        
        function updateStreak(isCorrect) {
            streak = isCorrect ? streak + 1 : 0;
            streakCountEl.textContent = streak;
            const streakEl = streakCountEl.parentElement;
            if (isCorrect && streak > 0) {
                streakEl.classList.add('animate-bounce');
                setTimeout(() => streakEl.classList.remove('animate-bounce'), 1000);
            }
        }
        
        function updateXp(isCorrect) {
            if (isCorrect) {
                const xpGained = 10 + (streak * 2); 
                xp += xpGained;
                if (xp >= xpPerLevel) {
                    xp = xp % xpPerLevel;
                    level++;
                    levelEl.textContent = level;
                    const levelIndicator = document.getElementById('level-indicator');
                    levelIndicator.classList.add('animate-pulse', 'scale-125');
                    setTimeout(()=> levelIndicator.classList.remove('animate-pulse', 'scale-125'), 1000);
                }
            }
            const xpPercentage = (xp / xpPerLevel) * 100;
            xpBarFill.style.width = `${xpPercentage}%`;
        }

        function revealBlockColors() {
             document.querySelectorAll('.sentence-block').forEach(el => {
                const blockData = currentSentence.blocks.find(b => b.id == el.dataset.id);
                if (!blockData) return;
                
                el.className = 'sentence-block p-3 pr-8 rounded-lg font-semibold shadow-md glass relative '; 
                let colorClasses = 'bg-gray-700/50 border-gray-600 text-gray-200';
                if (blockData.core) {
                    switch (blockData.type) {
                        case 'subject': colorClasses += ' bg-blue-500/50 border-blue-400 text-white neon-blue'; break;
                        case 'verb': colorClasses += ' bg-red-500/50 border-red-400 text-white neon-red'; break;
                        default: colorClasses += ' bg-green-500/50 border-green-400 text-white neon-green'; break;
                    }
                }
                el.classList.add(...colorClasses.split(' '));
             });
        }

        function displayFeedback(isCorrect) {
            feedbackContainer.innerHTML = '';
            const feedbackEl = document.createElement('div');
            feedbackEl.className = 'flex items-center justify-center gap-2 text-center font-bold text-lg';
            
            if (isCorrect) {
                feedbackEl.innerHTML = `<i class="fa-solid fa-circle-check text-2xl"></i> <span>${currentSentence.correctFeedback}</span>`;
                feedbackEl.classList.add('text-green-400', 'feedback-correct');
                analyzeMistakeBtn.classList.add('hidden');
            } else {
                const incorrectMessages = [ "어이쿠! 뼈대만 발라내야지!", "순서가 틀렸잖아? 다시!", "핵심 뼈대가 빠졌는데?" ];
                feedbackEl.innerHTML = `<i class="fa-solid fa-circle-xmark text-2xl"></i> <span>${incorrectMessages[Math.floor(Math.random() * incorrectMessages.length)]}</span>`;
                feedbackEl.classList.add('text-red-400', 'feedback-incorrect');
                analyzeMistakeBtn.classList.remove('hidden');
                analyzeMistakeBtn.disabled = false;
            }
            feedbackContainer.appendChild(feedbackEl);
            
            explanationTitle.innerHTML = `<i class="fa-solid fa-pen-to-square"></i> 대순's Point! 짚고 가기!`;
            explanationText.textContent = currentSentence.explanation;
            takeawayText.textContent = currentSentence.takeaway || '';
            takeawayContainer.style.display = currentSentence.takeaway ? 'block' : 'none';
            explanationSheet.classList.remove('hidden');
        }

        async function analyzeMistake() {
            if (!lastIncorrectAnswer) return;
            
            const btnOriginalText = analyzeMistakeBtn.innerHTML;
            analyzeMistakeBtn.innerHTML = `<i class="fa-solid fa-spinner animate-spin"></i> 분석 중...`;
            analyzeMistakeBtn.disabled = true;

            try {
                const correctCore = currentSentence.blocks.filter(b => b.core).map(b => b.text).join(' / ');
                const systemPrompt = `You are '김대순', a top-tier CSAT English instructor. A student tried to find the core components of the sentence "${currentSentence.full}". The correct core components are "${correctCore}". The student's incorrect answer was "${lastIncorrectAnswer}". In your punchy, direct persona, explain concisely in Korean WHY the student's answer is wrong. Point out their specific misunderstanding. Do not provide the full correct answer, just focus on the mistake.`;
                
                const analysis = await fetchSentenceFromAI("Analyze my mistake.", systemPrompt, true);
                
                if (analysis) {
                    explanationTitle.innerHTML = `<i class="fa-solid fa-magnifying-glass-chart"></i> 너의 오답, 정밀 분석!`;
                    explanationText.textContent = analysis;
                    takeawayContainer.style.display = 'none';
                } else {
                    explanationText.textContent = "오답 분석에 실패했어. 잠시 후 다시 시도해봐.";
                }
            } finally {
                 analyzeMistakeBtn.innerHTML = btnOriginalText;
                 analyzeMistakeBtn.disabled = false;
            }
        }

        function closeExplanation() { explanationSheet.classList.add('hidden'); }
        
        function base64ToArrayBuffer(base64) {
            const binaryString = window.atob(base64);
            const len = binaryString.length;
            const bytes = new Uint8Array(len);
            for (let i = 0; i < len; i++) { bytes[i] = binaryString.charCodeAt(i); }
            return bytes.buffer;
        }
        function pcmToWav(pcmData, sampleRate) { 
            const numChannels = 1, bytesPerSample = 2, blockAlign = numChannels * bytesPerSample;
            const byteRate = sampleRate * blockAlign, dataSize = pcmData.length * bytesPerSample;
            const buffer = new ArrayBuffer(44 + dataSize);
            const view = new DataView(buffer);
            view.setUint32(0, 0x52494646, false); 
            view.setUint32(4, 36 + dataSize, true); view.setUint32(8, 0x57415645, false); 
            view.setUint32(12, 0x666d7420, false); 
            view.setUint32(16, 16, true); view.setUint16(20, 1, true); view.setUint16(22, numChannels, true);
            view.setUint32(24, sampleRate, true); view.setUint32(28, byteRate, true);
            view.setUint16(32, blockAlign, true); view.setUint16(34, bytesPerSample * 8, true);
            view.setUint32(36, 0x64617461, false); 
            view.setUint32(40, dataSize, true);
            for (let i = 0; i < pcmData.length; i++) { view.setInt16(44 + i * 2, pcmData[i], true); }
            return new Blob([view], { type: 'audio/wav' });
        }
        
        async function playAudio(text, iconElement) {
            if (iconElement.classList.contains('fa-spinner')) return; 
            const originalIcon = iconElement.className;
            iconElement.className = 'fa-solid fa-spinner animate-spin text-cyan-400 speaker-icon';

            const maxRetries = 3;
            let delay = 1000;

            for (let attempt = 1; attempt <= maxRetries; attempt++) {
                try {
                    const ttsApiUrl = `https://generativelanguage.googleapis.com/v1beta/models/gemini-2.5-flash-preview-tts:generateContent?key=${apiKey}`;
                    const payload = {
                        contents: [{ parts: [{ text }] }],
                        generationConfig: { responseModalities: ["AUDIO"] },
                        model: "gemini-2.5-flash-preview-tts"
                    };
                    const response = await fetch(ttsApiUrl, { method: 'POST', headers: { 'Content-Type': 'application/json' }, body: JSON.stringify(payload) });
                    
                    if (!response.ok) {
                        const errorData = await response.json().catch(() => ({ error: { message: `HTTP Error: ${response.status}` } }));
                        if (response.status === 429 || response.status === 503 || (errorData.error && errorData.error.message.includes("overloaded"))) {
                           throw new Error(`Retryable Error: ${errorData.error.message}`);
                        }
                        throw new Error(`Non-retryable Error: ${errorData.error.message}`);
                    }

                    const result = await response.json();
                    const audioData = result?.candidates?.[0]?.content?.parts?.[0]?.inlineData?.data;
                    const mimeType = result?.candidates?.[0]?.content?.parts?.[0]?.inlineData?.mimeType;

                    if (audioData && mimeType && mimeType.startsWith("audio/")) {
                        const sampleRate = parseInt(mimeType.match(/rate=(\d+)/)[1], 10);
                        const pcmBuffer = base64ToArrayBuffer(audioData);
                        const pcm16 = new Int16Array(pcmBuffer);
                        const wavBlob = pcmToWav(pcm16, sampleRate);
                        const audioUrl = URL.createObjectURL(wavBlob);
                        new Audio(audioUrl).play();
                        iconElement.className = originalIcon;
                        return;
                    } else {
                        throw new Error('Invalid audio data received');
                    }
                } catch (error) {
                    console.error(`TTS Attempt ${attempt} failed:`, error);
                    if (error.message.startsWith("Non-retryable") || attempt === maxRetries) {
                        console.error("Error playing audio: Could not recover after retries.", error);
                        iconElement.className = originalIcon;
                        break;
                    }
                    await new Promise(res => setTimeout(res, delay));
                    delay *= 2;
                }
            }
        }

        checkBtn.addEventListener('click', checkAnswer);
        nextBtn.addEventListener('click', getNextSentence);
        modeToggle.addEventListener('change', () => {
            updateToggleLabels();
            getNextSentence();
        });
        closeExplanationBtn.addEventListener('click', closeExplanation);
        explanationBackdrop.addEventListener('click', closeExplanation);
        analyzeMistakeBtn.addEventListener('click', analyzeMistake);
        
        similarSentenceBtn.addEventListener('click', () => {
             const prompt = `The previous grammar point was about: "${currentSentence.explanation}". Generate a NEW sentence that tests the same grammar concept but uses different vocabulary. It must not be from a past paper and you must not include the 'source' field in the JSON.`;
             fetchSentenceFromAI(prompt);
        });
        
        mainContent.addEventListener('click', e => {
            if (e.target.classList.contains('speaker-icon')) {
                const text = e.target.closest('.sentence-block').querySelector('span').textContent;
                playAudio(text, e.target);
            }
        });

        document.addEventListener('DOMContentLoaded', () => {
            updateToggleLabels();
            getNextSentence();
        });
    </script>
</body>
</html>

